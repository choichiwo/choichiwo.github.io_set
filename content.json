{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Starthihih Create a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/10/29/hello-world/"},{"title":"titanic","text":"Kaggle API 설치 Google Colab에서 Kaggle API를 불러오려면 다음 소스코드를 실행한다. 1!pip install kaggle Requirement already satisfied: kaggle in /usr/local/lib/python3.6/dist-packages (1.5.9) Requirement already satisfied: six&gt;=1.10 in /usr/local/lib/python3.6/dist-packages (from kaggle) (1.15.0) Requirement already satisfied: urllib3 in /usr/local/lib/python3.6/dist-packages (from kaggle) (1.24.3) Requirement already satisfied: slugify in /usr/local/lib/python3.6/dist-packages (from kaggle) (0.0.1) Requirement already satisfied: python-dateutil in /usr/local/lib/python3.6/dist-packages (from kaggle) (2.8.1) Requirement already satisfied: tqdm in /usr/local/lib/python3.6/dist-packages (from kaggle) (4.41.1) Requirement already satisfied: python-slugify in /usr/local/lib/python3.6/dist-packages (from kaggle) (4.0.1) Requirement already satisfied: requests in /usr/local/lib/python3.6/dist-packages (from kaggle) (2.23.0) Requirement already satisfied: certifi in /usr/local/lib/python3.6/dist-packages (from kaggle) (2020.6.20) Requirement already satisfied: text-unidecode&gt;=1.3 in /usr/local/lib/python3.6/dist-packages (from python-slugify-&gt;kaggle) (1.3) Requirement already satisfied: chardet&lt;4,&gt;=3.0.2 in /usr/local/lib/python3.6/dist-packages (from requests-&gt;kaggle) (3.0.4) Requirement already satisfied: idna&lt;3,&gt;=2.5 in /usr/local/lib/python3.6/dist-packages (from requests-&gt;kaggle) (2.10) 1. Kaggle Token 다운로드 Kaggle에서 API Token을 다운로드 받는다. [Kaggle]-[My Account]-[API]-[Create New API Token]을 누르면 kaggle.json 파일이 다운로드 된다. 이 파일을 바탕화면에 옮긴 뒤, 아래 코드(토큰을 실행시키는 코드)를 실행 시킨다. 12345678from google.colab import filesuploaded = files.upload()for fn in uploaded.keys(): print('uploaded file &quot;{name}&quot; with length {length} bytes'.format( name=fn, length=len(uploaded[fn]))) # kaggle.json을 아래 폴더로 옮긴 뒤, file을 사용할 수 있도록 권한을 부여한다. !mkdir -p ~/.kaggle/ &amp;&amp; mv kaggle.json ~/.kaggle/ &amp;&amp; chmod 600 ~/.kaggle/kaggle.json Upload widget is only available when the cell has been executed in the current browser session. Please rerun this cell to enable. Saving kaggle.json to kaggle.json uploaded file &quot;kaggle.json&quot; with length 66 bytes 아래 코드는 실행됬는지 확인하는 코드 1ls -1ha ~/.kaggle/kaggle.json /root/.kaggle/kaggle.json 1 2. Kaggle 데이터 불러오기 먼저 kaggle competition list를 불러온다. 1!kaggle competitions list Warning: Looks like you're using an outdated API Version, please consider updating (server 1.5.9 / client 1.5.4) ref deadline category reward teamCount userHasEntered --------------------------------------------- ------------------- --------------- --------- --------- -------------- contradictory-my-dear-watson 2030-07-01 23:59:00 Getting Started Prizes 134 False gan-getting-started 2030-07-01 23:59:00 Getting Started Prizes 185 False tpu-getting-started 2030-06-03 23:59:00 Getting Started Knowledge 315 False digit-recognizer 2030-01-01 00:00:00 Getting Started Knowledge 2356 False titanic 2030-01-01 00:00:00 Getting Started Knowledge 18058 True house-prices-advanced-regression-techniques 2030-01-01 00:00:00 Getting Started Knowledge 4536 True connectx 2030-01-01 00:00:00 Getting Started Knowledge 390 False nlp-getting-started 2030-01-01 00:00:00 Getting Started Knowledge 1184 False rock-paper-scissors 2021-02-01 23:59:00 Playground Prizes 152 False riiid-test-answer-prediction 2021-01-07 23:59:00 Featured $100,000 1466 False nfl-big-data-bowl-2021 2021-01-05 23:59:00 Analytics $100,000 0 False competitive-data-science-predict-future-sales 2020-12-31 23:59:00 Playground Kudos 9343 False halite-iv-playground-edition 2020-12-31 23:59:00 Playground Knowledge 43 False predict-volcanic-eruptions-ingv-oe 2020-12-28 23:59:00 Playground Swag 193 False hashcode-drone-delivery 2020-12-14 23:59:00 Playground Knowledge 79 False cdp-unlocking-climate-solutions 2020-12-02 23:59:00 Analytics $91,000 0 False lish-moa 2020-11-30 23:59:00 Research $30,000 3395 False google-football 2020-11-30 23:59:00 Featured $6,000 916 False conways-reverse-game-of-life-2020 2020-11-30 23:59:00 Playground Swag 131 False lyft-motion-prediction-autonomous-vehicles 2020-11-25 23:59:00 Featured $30,000 778 False 1!kaggle competitions download -c titanic Warning: Looks like you're using an outdated API Version, please consider updating (server 1.5.9 / client 1.5.4) Downloading gender_submission.csv to /content 0% 0.00/3.18k [00:00&lt;?, ?B/s] 100% 3.18k/3.18k [00:00&lt;00:00, 6.86MB/s] Downloading test.csv to /content 0% 0.00/28.0k [00:00&lt;?, ?B/s] 100% 28.0k/28.0k [00:00&lt;00:00, 23.4MB/s] Downloading train.csv to /content 0% 0.00/59.8k [00:00&lt;?, ?B/s] 100% 59.8k/59.8k [00:00&lt;00:00, 52.2MB/s] ls는 디렉터리(파일,경로) 내의 데이터 파일을 보여주는 명령어 1!ls gender_submission.csv sample_data test.csv train.csv 현재 총 4개의 데이터를 다운로드 받았다. gender_submission.csv sample_data test.csv train.csv 3. 캐글 데이터 수집 및 EDA 우선 데이터를 수집하기에 앞서서 EDA에 관한 필수 패키지를 설치하자. 1234567891011import pandas as pd # 데이터 가공 변환(deploy)import pandas_profiling # 보고서 기능 import numpy as np # 수치연산 &amp; 배열 import matplotlib as mplimport matplotlib.pyplot as pltimport seaborn as snsplt.style.use('fivethirtyeight')import warningswarnings.filterwarnings('ignore')%matplotlib inlinefrom IPython.core.display import display, HTML (1) 데이터 불러오기 지난 시간에 받은 데이터가 총 4개임을 확인했다. gender_submission.csv sample_data test.csv train.csv 여기에서는 우선 test.csv &amp; train.csv 파일을 받도록 한다. 123train = pd.read_csv('train.csv')test = pd.read_csv('test.csv')print(&quot;data import is done&quot;) data import is done (2) 데이터 확인 Kaggle 데이터를 불러오면 우선 확인해야 하는 것은 데이터셋의 크기다. 변수의 갯수 Numeric 변수 &amp; Categorical 변수의 개수 등을 파악해야 한다. Point 1 - train데이터에서 굳이 훈련데이터와 테스트 데이터를 구분할 필요는 없다. 보통 Kaggle에서는 테스트 데이터를 주기적으로 업데이트 해준다. Point 2 - 보통 test 데이터의 변수의 개수가 하나 더 작다. 1train.shape, test.shape ((891, 12), (418, 11)) 그 후 train데이터의 상위 5개의 데이터만 확인한다. 1display(train.head()) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } PassengerId Survived Pclass Name Sex Age SibSp Parch Ticket Fare Cabin Embarked 0 1 0 3 Braund, Mr. Owen Harris male 22.0 1 0 A/5 21171 7.2500 NaN S 1 2 1 1 Cumings, Mrs. John Bradley (Florence Briggs Th... female 38.0 1 0 PC 17599 71.2833 C85 C 2 3 1 3 Heikkinen, Miss. Laina female 26.0 0 0 STON/O2. 3101282 7.9250 NaN S 3 4 1 1 Futrelle, Mrs. Jacques Heath (Lily May Peel) female 35.0 1 0 113803 53.1000 C123 S 4 5 0 3 Allen, Mr. William Henry male 35.0 0 0 373450 8.0500 NaN S 아래 코드는 train.csv을 data로 변환 한다. 1data=pd.read_csv('train.csv') 1data.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } PassengerId Survived Pclass Name Sex Age SibSp Parch Ticket Fare Cabin Embarked 0 1 0 3 Braund, Mr. Owen Harris male 22.0 1 0 A/5 21171 7.2500 NaN S 1 2 1 1 Cumings, Mrs. John Bradley (Florence Briggs Th... female 38.0 1 0 PC 17599 71.2833 C85 C 2 3 1 3 Heikkinen, Miss. Laina female 26.0 0 0 STON/O2. 3101282 7.9250 NaN S 3 4 1 1 Futrelle, Mrs. Jacques Heath (Lily May Peel) female 35.0 1 0 113803 53.1000 C123 S 4 5 0 3 Allen, Mr. William Henry male 35.0 0 0 373450 8.0500 NaN S 1data.isnull().sum() PassengerId 0 Survived 0 Pclass 0 Name 0 Sex 0 Age 177 SibSp 0 Parch 0 Ticket 0 Fare 0 Cabin 687 Embarked 2 dtype: int64 The Age, Cabin and Embarked 에 대한 결측값을 구한다. 얼마나 살아남았나?1234567f,ax=plt.subplots(1,2,figsize=(18,8))data['Survived'].value_counts().plot.pie(explode=[0,0.1],autopct='%1.1f%%',ax=ax[0],shadow=True)ax[0].set_title('Survived')ax[0].set_ylabel('')sns.countplot('Survived',data=data,ax=ax[1])ax[1].set_title('Survived')plt.show() 그 사고에서 살아남은 승객이 많지 않다는 것은 명백하다. 훈련장 891명 중 350명 정도만 살아남았다. 즉, 전체 훈련장 중 38.4%만이 추락사고에서 살아남았다. 우리는 데이터로부터 더 나은 통찰력을 얻고 어떤 범주의 승객들이 살아남았는지 그리고 누가 살아남지 않았는지 보기 위해 더 많은 정보를 캐내야 한다. 우리는 데이터 세트의 다른 특징들을 사용하여 생존율을 확인하도록 노력할 것이다. Sex, Port Of Embarcation, Age 등이 특징이다. 먼저 다양한 유형의 특징을 이해하십시오. 피쳐 유형 범주형 피쳐:범주형 변수는 두 개 이상의 범주를 가진 변수 중 하나이며, 해당 형상의 각 값은 범주별로 분류할 수 있다.예를 들어, 성별은 두 개의 범주(남성과 여성)를 갖는 범주형 변수다. 이제 우리는 그러한 변수들에 대해 어떠한 순서도 정렬할 수 없다. 이 변수들은 공칭 변수라고도 한다. 데이터 집합의 범주형 특징: 성별, 도착. 순서형 피쳐:순서형 변수는 범주형 값과 비슷하지만, 그 값들 사이의 차이는 우리가 상대적인 순서나 값들 사이의 정렬을 가질 수 있다는 것이다. 예를 들어: 높이에 높은 값, 중간 값, 짧은 값과 같은 특징이 있다면 높이는 서수 변수다. 여기서 우리는 변수에서 상대적인 분류법을 가질 수 있다. 데이터 집합의 순서형 기능: PClass 연속 기능:형상은 형상 열의 두 점 또는 최소값 또는 최대값 사이에 값을 취할 수 있는 경우 지속된다고 한다. 데이터 집합의 지속적인 기능: 나이 특성 분석성–&gt; 범주형 특징 1data.groupby(['Sex','Survived'])['Survived'].count() Sex Survived female 0 81 1 233 male 0 468 1 109 Name: Survived, dtype: int64 123456f,ax=plt.subplots(1,2,figsize=(18,8))data[['Sex','Survived']].groupby(['Sex']).mean().plot.bar(ax=ax[0])ax[0].set_title('Survived vs Sex')sns.countplot('Sex',hue='Survived',data=data,ax=ax[1])ax[1].set_title('Sex:Survived vs Dead')plt.show() 배에 타고 있는 남자들의 수가 여자들의 수보다 훨씬 많다. 그러나 여전히 구조된 여성의 수는 구조된 남성의 수보다 거의 두 배나 많다. 배에 타고 있는 여성의 생존율은 약 75%인 반면 남성은 약 18-19%이다. 이것은 모델링을 위해 매우 중요한 특징으로 보인다. 하지만 그게 최고일까? 다른 기능을 확인해 봅시다. Pclass –&gt; 순서형 피쳐1pd.crosstab(data.Pclass,data.Survived,margins=True).style.background_gradient(cmap='summer_r') #T_ceb04e82_1e4a_11eb_b25f_0242ac1c0002row0_col0,#T_ceb04e82_1e4a_11eb_b25f_0242ac1c0002row1_col1,#T_ceb04e82_1e4a_11eb_b25f_0242ac1c0002row1_col2{ background-color: #ffff66; color: #000000; }#T_ceb04e82_1e4a_11eb_b25f_0242ac1c0002row0_col1{ background-color: #cee666; color: #000000; }#T_ceb04e82_1e4a_11eb_b25f_0242ac1c0002row0_col2{ background-color: #f4fa66; color: #000000; }#T_ceb04e82_1e4a_11eb_b25f_0242ac1c0002row1_col0{ background-color: #f6fa66; color: #000000; }#T_ceb04e82_1e4a_11eb_b25f_0242ac1c0002row2_col0{ background-color: #60b066; color: #000000; }#T_ceb04e82_1e4a_11eb_b25f_0242ac1c0002row2_col1{ background-color: #dfef66; color: #000000; }#T_ceb04e82_1e4a_11eb_b25f_0242ac1c0002row2_col2{ background-color: #90c866; color: #000000; }#T_ceb04e82_1e4a_11eb_b25f_0242ac1c0002row3_col0,#T_ceb04e82_1e4a_11eb_b25f_0242ac1c0002row3_col1,#T_ceb04e82_1e4a_11eb_b25f_0242ac1c0002row3_col2{ background-color: #008066; color: #f1f1f1; } Survived 0 1 All Pclass 1 80 136 216 2 97 87 184 3 372 119 491 All 549 342 891 1234567f,ax=plt.subplots(1,2,figsize=(18,8))data['Pclass'].value_counts().plot.bar(color=['#CD7F32','#FFDF00','#D3D3D3'],ax=ax[0])ax[0].set_title('Number Of Passengers By Pclass')ax[0].set_ylabel('Count')sns.countplot('Pclass',hue='Survived',data=data,ax=ax[1])ax[1].set_title('Pclass:Survived vs Dead')plt.show() P클래스사람은 돈이 모든 것을 살 수 없다고 말한다. 그러나 우리는 구조하는 동안 P클래스 1의 승객이 매우 높은 우선순위를 부여받았다는 것을 분명히 알 수 있다. P클래스 3의 탑승객 수가 훨씬 더 많았지만, 여전히 탑승객들로부터 생존하는 사람들의 수는 약 25%로 매우 낮다. P클래스의 경우 1% 생존율이 약 63%인 반면 P클래스2의 경우 약 48%이다. 그래서 돈과 지위가 중요하다. 그런 물질적인 세계. 좀 더 자세히 살펴보고 다른 흥미로운 관찰을 확인해 봅시다. 성과 P클래스 통해 생존율을 확인해보자. 1pd.crosstab([data.Sex,data.Survived],data.Pclass,margins=True).style.background_gradient(cmap='summer_r') #T_2327443c_1e4d_11eb_b25f_0242ac1c0002row0_col0,#T_2327443c_1e4d_11eb_b25f_0242ac1c0002row0_col1,#T_2327443c_1e4d_11eb_b25f_0242ac1c0002row0_col3,#T_2327443c_1e4d_11eb_b25f_0242ac1c0002row3_col2{ background-color: #ffff66; color: #000000; }#T_2327443c_1e4d_11eb_b25f_0242ac1c0002row0_col2,#T_2327443c_1e4d_11eb_b25f_0242ac1c0002row1_col2{ background-color: #f1f866; color: #000000; }#T_2327443c_1e4d_11eb_b25f_0242ac1c0002row1_col0{ background-color: #96cb66; color: #000000; }#T_2327443c_1e4d_11eb_b25f_0242ac1c0002row1_col1{ background-color: #a3d166; color: #000000; }#T_2327443c_1e4d_11eb_b25f_0242ac1c0002row1_col3{ background-color: #cfe766; color: #000000; }#T_2327443c_1e4d_11eb_b25f_0242ac1c0002row2_col0{ background-color: #a7d366; color: #000000; }#T_2327443c_1e4d_11eb_b25f_0242ac1c0002row2_col1,#T_2327443c_1e4d_11eb_b25f_0242ac1c0002row2_col3{ background-color: #85c266; color: #000000; }#T_2327443c_1e4d_11eb_b25f_0242ac1c0002row2_col2{ background-color: #6eb666; color: #000000; }#T_2327443c_1e4d_11eb_b25f_0242ac1c0002row3_col0{ background-color: #cde666; color: #000000; }#T_2327443c_1e4d_11eb_b25f_0242ac1c0002row3_col1{ background-color: #f0f866; color: #000000; }#T_2327443c_1e4d_11eb_b25f_0242ac1c0002row3_col3{ background-color: #f7fb66; color: #000000; }#T_2327443c_1e4d_11eb_b25f_0242ac1c0002row4_col0,#T_2327443c_1e4d_11eb_b25f_0242ac1c0002row4_col1,#T_2327443c_1e4d_11eb_b25f_0242ac1c0002row4_col2,#T_2327443c_1e4d_11eb_b25f_0242ac1c0002row4_col3{ background-color: #008066; color: #f1f1f1; } Pclass 1 2 3 All Sex Survived female 0 3 6 72 81 1 91 70 72 233 male 0 77 91 300 468 1 45 17 47 109 All 216 184 491 891 12sns.factorplot('Pclass','Survived',hue='Sex',data=data) #성에 따른 Pclass 생존율plt.show() 이 경우 요인 그림은 범주형 값의 분리가 쉽기 때문에 요인 그림을 사용한다. 크로스탭과 인자 플롯을 보면 Pclass1 여성 94명 중 3명만이 사망했기 때문에 Pclass1 여성 생존율이 약 95~96%라고 쉽게 유추할 수 있다. Pclass와 관계 없이 구조하는 동안 여성에게 우선권이 주어졌다는 것은 명백하다. 심지어 Pclass1 출신의 남성들도 생존율이 매우 낮다. Pclass도 중요한 특징인 것 같다. 다른 특징을 분석해보자. 나이 –&gt; 지속적 특징123print('Oldest Passenger was of:',data['Age'].max(),'Years') #최대 나이 승객print('Youngest Passenger was of:',data['Age'].min(),'Years') #최소 나이 승객 print('Average Age on the ship:',data['Age'].mean(),'Years') #평균 나이 승객 Oldest Passenger was of: 80.0 Years Youngest Passenger was of: 0.42 Years Average Age on the ship: 29.69911764705882 Years 12345678f,ax=plt.subplots(1,2,figsize=(18,8))sns.violinplot(&quot;Pclass&quot;,&quot;Age&quot;, hue=&quot;Survived&quot;, data=data,split=True,ax=ax[0])ax[0].set_title('Pclass and Age vs Survived') #제목ax[0].set_yticks(range(0,110,10)) sns.violinplot(&quot;Sex&quot;,&quot;Age&quot;, hue=&quot;Survived&quot;, data=data,split=True,ax=ax[1])ax[1].set_title('Sex and Age vs Survived') #제목ax[1].set_yticks(range(0,110,10))plt.show() 관측치:1)P클래스에 따라 자녀 수가 증가하고 10세 미만(즉, 자녀)의 패시네거 생존율은 P클래스에 관계없이 양호한 것으로 보인다. 2)Pclass1에서 20-50세의 승객의 생존 가능성은 높고 여성에게는 더욱 좋다. 3)남성의 경우 나이가 들수록 생존 가능성이 줄어든다. 앞에서 보았듯이 에이지 기능은 177개의 null 값을 가지고 있다. 이러한 NaN 값을 대체하기 위해 데이터 집합의 평균 연령을 할당할 수 있다. 그런데 문제는 나이 차이가 많은 사람들이 많았다는 겁니다. 우리는 단지 평균 나이 29세인 4살 아이를 배정할 수 없다. 승객이 어떤 연령대인지 알 수 있는 방법은 없을까? 이름 기능을 확인할 수 있어. 그 특징을 살펴보면, 우리는 그 이름들이 Mr. 또는 Mrs.와 같은 경례를 가지고 있다는 것을 알 수 있다. 따라서 우리는 Mr. Mrs와 Mrs의 평균값을 각 그룹에 할당할 수 있다. ‘’이름에 무엇이 있는가?”—&gt; 특징 :p123data['Initial']=0for i in data: data['Initial']=data.Name.str.extract('([A-Za-z]+)\\.') #인사말을 꺼내자. 자, 이제 Regex를 사용합시다. [A-Za-z]+).. 즉, A-Z 또는 a-z 사이에 있는 문자열을 찾고, 그 뒤에 .(점)이 있는 문자열을 찾는 겁니다. 그래서 우리는 이름에서 이니셜을 성공적으로 추출했다. 1pd.crosstab(data.Initial,data.Sex).T.style.background_gradient(cmap='summer_r') #성으로 이니셜 확인 #T_392ab74e_1e4f_11eb_b25f_0242ac1c0002row0_col0,#T_392ab74e_1e4f_11eb_b25f_0242ac1c0002row0_col1,#T_392ab74e_1e4f_11eb_b25f_0242ac1c0002row0_col3,#T_392ab74e_1e4f_11eb_b25f_0242ac1c0002row0_col4,#T_392ab74e_1e4f_11eb_b25f_0242ac1c0002row0_col5,#T_392ab74e_1e4f_11eb_b25f_0242ac1c0002row0_col7,#T_392ab74e_1e4f_11eb_b25f_0242ac1c0002row0_col8,#T_392ab74e_1e4f_11eb_b25f_0242ac1c0002row0_col12,#T_392ab74e_1e4f_11eb_b25f_0242ac1c0002row0_col15,#T_392ab74e_1e4f_11eb_b25f_0242ac1c0002row0_col16,#T_392ab74e_1e4f_11eb_b25f_0242ac1c0002row1_col2,#T_392ab74e_1e4f_11eb_b25f_0242ac1c0002row1_col6,#T_392ab74e_1e4f_11eb_b25f_0242ac1c0002row1_col9,#T_392ab74e_1e4f_11eb_b25f_0242ac1c0002row1_col10,#T_392ab74e_1e4f_11eb_b25f_0242ac1c0002row1_col11,#T_392ab74e_1e4f_11eb_b25f_0242ac1c0002row1_col13,#T_392ab74e_1e4f_11eb_b25f_0242ac1c0002row1_col14{ background-color: #ffff66; color: #000000; }#T_392ab74e_1e4f_11eb_b25f_0242ac1c0002row0_col2,#T_392ab74e_1e4f_11eb_b25f_0242ac1c0002row0_col6,#T_392ab74e_1e4f_11eb_b25f_0242ac1c0002row0_col9,#T_392ab74e_1e4f_11eb_b25f_0242ac1c0002row0_col10,#T_392ab74e_1e4f_11eb_b25f_0242ac1c0002row0_col11,#T_392ab74e_1e4f_11eb_b25f_0242ac1c0002row0_col13,#T_392ab74e_1e4f_11eb_b25f_0242ac1c0002row0_col14,#T_392ab74e_1e4f_11eb_b25f_0242ac1c0002row1_col0,#T_392ab74e_1e4f_11eb_b25f_0242ac1c0002row1_col1,#T_392ab74e_1e4f_11eb_b25f_0242ac1c0002row1_col3,#T_392ab74e_1e4f_11eb_b25f_0242ac1c0002row1_col4,#T_392ab74e_1e4f_11eb_b25f_0242ac1c0002row1_col5,#T_392ab74e_1e4f_11eb_b25f_0242ac1c0002row1_col7,#T_392ab74e_1e4f_11eb_b25f_0242ac1c0002row1_col8,#T_392ab74e_1e4f_11eb_b25f_0242ac1c0002row1_col12,#T_392ab74e_1e4f_11eb_b25f_0242ac1c0002row1_col15,#T_392ab74e_1e4f_11eb_b25f_0242ac1c0002row1_col16{ background-color: #008066; color: #f1f1f1; } Initial Capt Col Countess Don Dr Jonkheer Lady Major Master Miss Mlle Mme Mr Mrs Ms Rev Sir Sex female 0 0 1 0 1 0 1 0 0 182 2 1 0 125 1 0 0 male 1 2 0 1 6 1 0 2 40 0 0 0 517 0 0 6 1 좋아, Mlle이나 Mme와 같은 철자가 틀린 이니셜이 있는데 Miss를 나타낸다. 나는 그것들을 미스나 다른 가치에 대해서도 같은 것으로 대체할 것이다.아래 코드 참조 1data['Initial'].replace(['Mlle','Mme','Ms','Dr','Major','Lady','Countess','Jonkheer','Col','Rev','Capt','Sir','Don'],['Miss','Miss','Miss','Mr','Mr','Mrs','Mrs','Other','Other','Other','Mr','Mr','Mr'],inplace=True) 1data.groupby('Initial')['Age'].mean() #이니셜별 평균 연령 확인 Initial Master 4.574167 Miss 21.860000 Mr 32.739609 Mrs 35.981818 Other 45.888889 Name: Age, dtype: float64 NaN 연령 채우기 123456## 평균 연령의 Ceil 값에 NaN 값 할당data.loc[(data.Age.isnull())&amp;(data.Initial=='Mr'),'Age']=33data.loc[(data.Age.isnull())&amp;(data.Initial=='Mrs'),'Age']=36data.loc[(data.Age.isnull())&amp;(data.Initial=='Master'),'Age']=5data.loc[(data.Age.isnull())&amp;(data.Initial=='Miss'),'Age']=22data.loc[(data.Age.isnull())&amp;(data.Initial=='Other'),'Age']=46 1data.Age.isnull().any() #그래서 마침내 null 값이 남지 않게 되었다. False 12345678910f,ax=plt.subplots(1,2,figsize=(20,10))data[data['Survived']==0].Age.plot.hist(ax=ax[0],bins=20,edgecolor='black',color='red')ax[0].set_title('Survived= 0')x1=list(range(0,85,5))ax[0].set_xticks(x1)data[data['Survived']==1].Age.plot.hist(ax=ax[1],color='green',bins=20,edgecolor='black')ax[1].set_title('Survived= 1')x2=list(range(0,85,5))ax[1].set_xticks(x2)plt.show() 관측치:1)아기들 (&lt;5)은 대량으로 생존되었다. 2)가장 나이가 많은 승객은 생존했다(80년). 3)최대 사망자는 30~40세였다. 12sns.factorplot('Pclass','Survived',col='Initial',data=data)plt.show() 따라서 부녀자 우선 정책은 계층에 관계없이 적용된다. 승선 –&gt; 범주형 값1pd.crosstab([data.Embarked,data.Pclass],[data.Sex,data.Survived],margins=True).style.background_gradient(cmap='summer_r') #T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row0_col0,#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row1_col2{ background-color: #fcfe66; color: #000000; }#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row0_col1{ background-color: #d2e866; color: #000000; }#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row0_col2{ background-color: #f2f866; color: #000000; }#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row0_col3{ background-color: #d8ec66; color: #000000; }#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row0_col4,#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row2_col3{ background-color: #e8f466; color: #000000; }#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row1_col0,#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row3_col0,#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row3_col1,#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row3_col2,#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row3_col3,#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row3_col4,#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row4_col0,#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row4_col2,#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row4_col3,#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row4_col4{ background-color: #ffff66; color: #000000; }#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row1_col1,#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row6_col0{ background-color: #f9fc66; color: #000000; }#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row1_col3,#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row1_col4{ background-color: #fbfd66; color: #000000; }#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row2_col0,#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row5_col1{ background-color: #e6f266; color: #000000; }#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row2_col1{ background-color: #f0f866; color: #000000; }#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row2_col2{ background-color: #eef666; color: #000000; }#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row2_col4,#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row7_col0{ background-color: #edf666; color: #000000; }#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row4_col1{ background-color: #fefe66; color: #000000; }#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row5_col0{ background-color: #e3f166; color: #000000; }#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row5_col2{ background-color: #ecf666; color: #000000; }#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row5_col3{ background-color: #f8fc66; color: #000000; }#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row5_col4{ background-color: #ebf566; color: #000000; }#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row6_col1{ background-color: #cde666; color: #000000; }#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row6_col2{ background-color: #e4f266; color: #000000; }#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row6_col3{ background-color: #bede66; color: #000000; }#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row6_col4{ background-color: #dbed66; color: #000000; }#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row7_col1{ background-color: #bdde66; color: #000000; }#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row7_col2{ background-color: #d3e966; color: #000000; }#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row7_col3,#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row8_col1{ background-color: #dcee66; color: #000000; }#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row7_col4{ background-color: #d1e866; color: #000000; }#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row8_col0{ background-color: #52a866; color: #000000; }#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row8_col2{ background-color: #81c066; color: #000000; }#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row8_col3{ background-color: #b0d866; color: #000000; }#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row8_col4{ background-color: #9acc66; color: #000000; }#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row9_col0,#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row9_col1,#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row9_col2,#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row9_col3,#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row9_col4{ background-color: #008066; color: #f1f1f1; } Sex female male All Survived 0 1 0 1 Embarked Pclass C 1 1 42 25 17 85 2 0 7 8 2 17 3 8 15 33 10 66 Q 1 0 1 1 0 2 2 0 2 1 0 3 3 9 24 36 3 72 S 1 2 46 51 28 127 2 6 61 82 15 164 3 55 33 231 34 353 All 81 231 468 109 889 항구별 생존 가능성 1234sns.factorplot('Embarked','Survived',data=data)fig=plt.gcf()fig.set_size_inches(5,3)plt.show() 포트 C의 생존 가능성은 0.55 전후로 가장 높은 반면 S의 생존 가능성은 가장 낮다. 1234567891011f,ax=plt.subplots(2,2,figsize=(20,15))sns.countplot('Embarked',data=data,ax=ax[0,0]) #sns = seabornax[0,0].set_title('No. Of Passengers Boarded')sns.countplot('Embarked',hue='Sex',data=data,ax=ax[0,1])ax[0,1].set_title('Male-Female Split for Embarked')sns.countplot('Embarked',hue='Survived',data=data,ax=ax[1,0])ax[1,0].set_title('Embarked vs Survived')sns.countplot('Embarked',hue='Pclass',data=data,ax=ax[1,1])ax[1,1].set_title('Embarked vs Pclass')plt.subplots_adjust(wspace=0.2,hspace=0.5)plt.show() 관측치:1)S에서 탑승한 최대 탑승객. 그들 대부분은 Pclass3 출신이다. 2)C에서 온 승객들은 상당부분 살아남은 것으로 보아 운이 좋은 것으로 보인다. 그 이유는 아마도 모든 Pclass1과 Pclass2 승객을 구조했을 것이다. 3)승객 S는 부자들의 대다수가 탑승한 항구를 바라본다. 여전히 생존 가능성은 낮은데, 그것은 81% 정도 되는 Pclass3의 많은 승객들이 살아남지금은 Pclass3의 많은 승객들이 살아남지 못했기 때문이다. 4)항구 Q의 탑승객은 거의 95%가 Pclass3 출신이었다. 12sns.factorplot('Pclass','Survived',hue='Sex',col='Embarked',data=data)plt.show() 관측치:1)Pclass1과 Pclass2의 여성은 Pclass와 관계없이 생존 확률은 거의 1이다. 2)남녀 모두의 생존율이 매우 낮기 때문에 Pclass3 Passenger에게는 포트S가 매우 불행해 보인다.(돈 문제) 3)포트 Q는 거의 모두가 Pclass 3에서 온 것처럼 남자에게는 가장 어울리지 않는 것 같다. 채우기 시작 NaN우리는 최대 승객들이 S항에서 탑승하는 것을 보았듯이 NaN을 S로 대체한다. 1data['Embarked'].fillna('S',inplace=True) 1data.Embarked.isnull().any()# Finally No NaN values False SibSip–&gt;구체적 특징이 특징은 사람이 혼자 있는지 가족과 함께 있는지 여부를 나타낸다. 형제 = 형제, 자매, 의붓동생, 의붓동생, 의붓동생 배우자 = 남편, 아내 1pd.crosstab([data.SibSp],data.Survived).style.background_gradient(cmap='summer_r') #T_728ddb78_1e5f_11eb_b25f_0242ac1c0002row0_col0,#T_728ddb78_1e5f_11eb_b25f_0242ac1c0002row0_col1{ background-color: #008066; color: #f1f1f1; }#T_728ddb78_1e5f_11eb_b25f_0242ac1c0002row1_col0{ background-color: #c4e266; color: #000000; }#T_728ddb78_1e5f_11eb_b25f_0242ac1c0002row1_col1{ background-color: #77bb66; color: #000000; }#T_728ddb78_1e5f_11eb_b25f_0242ac1c0002row2_col0,#T_728ddb78_1e5f_11eb_b25f_0242ac1c0002row4_col0{ background-color: #f9fc66; color: #000000; }#T_728ddb78_1e5f_11eb_b25f_0242ac1c0002row2_col1{ background-color: #f0f866; color: #000000; }#T_728ddb78_1e5f_11eb_b25f_0242ac1c0002row3_col0,#T_728ddb78_1e5f_11eb_b25f_0242ac1c0002row3_col1{ background-color: #fbfd66; color: #000000; }#T_728ddb78_1e5f_11eb_b25f_0242ac1c0002row4_col1{ background-color: #fcfe66; color: #000000; }#T_728ddb78_1e5f_11eb_b25f_0242ac1c0002row5_col0,#T_728ddb78_1e5f_11eb_b25f_0242ac1c0002row5_col1,#T_728ddb78_1e5f_11eb_b25f_0242ac1c0002row6_col1{ background-color: #ffff66; color: #000000; }#T_728ddb78_1e5f_11eb_b25f_0242ac1c0002row6_col0{ background-color: #fefe66; color: #000000; } Survived 0 1 SibSp 0 398 210 1 97 112 2 15 13 3 12 4 4 15 3 5 5 0 8 7 0 1234567f,ax=plt.subplots(1,2,figsize=(20,8))sns.barplot('SibSp','Survived',data=data,ax=ax[0])ax[0].set_title('SibSp vs Survived')sns.factorplot('SibSp','Survived',data=data,ax=ax[1])ax[1].set_title('SibSp vs Survived')plt.close(2)plt.show() 1pd.crosstab(data.SibSp,data.Pclass).style.background_gradient(cmap='summer_r') #T_83313358_1e5f_11eb_b25f_0242ac1c0002row0_col0,#T_83313358_1e5f_11eb_b25f_0242ac1c0002row0_col1,#T_83313358_1e5f_11eb_b25f_0242ac1c0002row0_col2{ background-color: #008066; color: #f1f1f1; }#T_83313358_1e5f_11eb_b25f_0242ac1c0002row1_col0{ background-color: #7bbd66; color: #000000; }#T_83313358_1e5f_11eb_b25f_0242ac1c0002row1_col1{ background-color: #8ac466; color: #000000; }#T_83313358_1e5f_11eb_b25f_0242ac1c0002row1_col2{ background-color: #c6e266; color: #000000; }#T_83313358_1e5f_11eb_b25f_0242ac1c0002row2_col0,#T_83313358_1e5f_11eb_b25f_0242ac1c0002row4_col2{ background-color: #f6fa66; color: #000000; }#T_83313358_1e5f_11eb_b25f_0242ac1c0002row2_col1{ background-color: #eef666; color: #000000; }#T_83313358_1e5f_11eb_b25f_0242ac1c0002row2_col2{ background-color: #f8fc66; color: #000000; }#T_83313358_1e5f_11eb_b25f_0242ac1c0002row3_col0,#T_83313358_1e5f_11eb_b25f_0242ac1c0002row3_col2{ background-color: #fafc66; color: #000000; }#T_83313358_1e5f_11eb_b25f_0242ac1c0002row3_col1{ background-color: #fdfe66; color: #000000; }#T_83313358_1e5f_11eb_b25f_0242ac1c0002row4_col0,#T_83313358_1e5f_11eb_b25f_0242ac1c0002row4_col1,#T_83313358_1e5f_11eb_b25f_0242ac1c0002row5_col0,#T_83313358_1e5f_11eb_b25f_0242ac1c0002row5_col1,#T_83313358_1e5f_11eb_b25f_0242ac1c0002row5_col2,#T_83313358_1e5f_11eb_b25f_0242ac1c0002row6_col0,#T_83313358_1e5f_11eb_b25f_0242ac1c0002row6_col1{ background-color: #ffff66; color: #000000; }#T_83313358_1e5f_11eb_b25f_0242ac1c0002row6_col2{ background-color: #fefe66; color: #000000; } Pclass 1 2 3 SibSp 0 137 120 351 1 71 55 83 2 5 8 15 3 3 1 12 4 0 0 18 5 0 0 5 8 0 0 7 관측치:막대 그래프와 요인 그림은 승객이 형제 없이 혼자 탑승한 경우 생존율이 34.5%라는 것을 보여준다. 형제자매 수가 증가하면 그래프는 대략 감소한다. 이게 말이 되네. 즉, 만약 내가 승선하고 있는 가족이 있다면, 나는 먼저 나 자신을 구하지 않고 그들을 구하려고 노력할 것이다. 놀랍게도 5~8인 가족의 생존율은 0%이다. 이유는 Pclass일 수도 있다? 그 이유는 Pclass이다. 십자표는 SibSp&gt;3을 가진 사람이 모두 Pclass3에 있었다는 것을 보여준다. Pclass3(&gt;&gt;3)의 대가족이 모두 사망하는 일이 임박했다. Parch1pd.crosstab(data.Parch,data.Pclass).style.background_gradient(cmap='summer_r') #T_ccb5b4d6_1e5f_11eb_b25f_0242ac1c0002row0_col0,#T_ccb5b4d6_1e5f_11eb_b25f_0242ac1c0002row0_col1,#T_ccb5b4d6_1e5f_11eb_b25f_0242ac1c0002row0_col2{ background-color: #008066; color: #f1f1f1; }#T_ccb5b4d6_1e5f_11eb_b25f_0242ac1c0002row1_col0{ background-color: #cfe766; color: #000000; }#T_ccb5b4d6_1e5f_11eb_b25f_0242ac1c0002row1_col1{ background-color: #c2e066; color: #000000; }#T_ccb5b4d6_1e5f_11eb_b25f_0242ac1c0002row1_col2{ background-color: #dbed66; color: #000000; }#T_ccb5b4d6_1e5f_11eb_b25f_0242ac1c0002row2_col0{ background-color: #dfef66; color: #000000; }#T_ccb5b4d6_1e5f_11eb_b25f_0242ac1c0002row2_col1{ background-color: #e1f066; color: #000000; }#T_ccb5b4d6_1e5f_11eb_b25f_0242ac1c0002row2_col2{ background-color: #e3f166; color: #000000; }#T_ccb5b4d6_1e5f_11eb_b25f_0242ac1c0002row3_col0,#T_ccb5b4d6_1e5f_11eb_b25f_0242ac1c0002row4_col1,#T_ccb5b4d6_1e5f_11eb_b25f_0242ac1c0002row5_col0,#T_ccb5b4d6_1e5f_11eb_b25f_0242ac1c0002row5_col1,#T_ccb5b4d6_1e5f_11eb_b25f_0242ac1c0002row6_col0,#T_ccb5b4d6_1e5f_11eb_b25f_0242ac1c0002row6_col1,#T_ccb5b4d6_1e5f_11eb_b25f_0242ac1c0002row6_col2{ background-color: #ffff66; color: #000000; }#T_ccb5b4d6_1e5f_11eb_b25f_0242ac1c0002row3_col1{ background-color: #fcfe66; color: #000000; }#T_ccb5b4d6_1e5f_11eb_b25f_0242ac1c0002row3_col2,#T_ccb5b4d6_1e5f_11eb_b25f_0242ac1c0002row4_col0,#T_ccb5b4d6_1e5f_11eb_b25f_0242ac1c0002row4_col2{ background-color: #fefe66; color: #000000; }#T_ccb5b4d6_1e5f_11eb_b25f_0242ac1c0002row5_col2{ background-color: #fdfe66; color: #000000; } Pclass 1 2 3 Parch 0 163 134 381 1 31 32 55 2 21 16 43 3 0 2 3 4 1 0 3 5 0 0 5 6 0 0 1 크로스탭은 다시 더 큰 가족이 Pclass3에 있었다는 것을 보여준다. 1234567f,ax=plt.subplots(1,2,figsize=(20,8))sns.barplot('Parch','Survived',data=data,ax=ax[0])ax[0].set_title('Parch vs Survived')sns.factorplot('Parch','Survived',data=data,ax=ax[1])ax[1].set_title('Parch vs Survived')plt.close(2)plt.show() 관측치:여기에서도 결과는 꽤 비슷하다. 부모를 동반한 승객은 생존 가능성이 더 크다. 하지만 숫자가 늘어날수록 줄어든다. 생존 가능성은 배 안에 1-3명의 부모를 둔 사람에게 좋다. 혼자라는 것은 또한 치명적이고 누군가가 배에 4명 이상의 부모를 두고 있을 때 생존 가능성이 줄어든다는 것을 증명한다. 운임–&gt; 지속적 특징123print('Highest Fare was:',data['Fare'].max()) #최고 요금print('Lowest Fare was:',data['Fare'].min()) #최저 요금print('Average Fare was:',data['Fare'].mean()) #평균 요금 Highest Fare was: 512.3292 Lowest Fare was: 0.0 Average Fare was: 32.2042079685746 12345678f,ax=plt.subplots(1,3,figsize=(20,8))sns.distplot(data[data['Pclass']==1].Fare,ax=ax[0])ax[0].set_title('Fares in Pclass 1')sns.distplot(data[data['Pclass']==2].Fare,ax=ax[1])ax[1].set_title('Fares in Pclass 2')sns.distplot(data[data['Pclass']==3].Fare,ax=ax[2])ax[2].set_title('Fares in Pclass 3')plt.show() Pclass1의 승객 요금에는 큰 배분이 있을 것으로 보이며, 이 배분은 기준이 감소함에 따라 계속 감소하고 있다. 이것 또한 지속적이기 때문에 우리는 바이닝을 사용하여 이산값으로 변환할 수 있다. 모든 형상에 대한 간단한 관측치:성=남성에 비해 여성의 생존 가능성은 높다. Pclass:일등석 승객이 되면 생존 가능성이 더 높아진다는 눈에 띄는 추세가 있다. Pclass3의 생존율은 매우 낮다. 여성의 경우 Pclass1에서 생존할 확률은 거의 1이며 Pclass2에서 생존할 확률도 높다. 돈이 이긴다!!! 나이: 5~10세 미만의 어린이들은 생존 확률이 높다. 15세에서 35세 사이의 승객들이 많이 죽었다. 시작됨: 이것은 매우 흥미로운 특징이다. Pclass1 승객의 대다수가 S. Q. 승객들이 모두 Pclass3 출신이었음에도 불구하고 C에서 생존할 가능성은 더 좋아 보인다. Parch+SibSp: 1-2명의 형제자매가 있고, 기내에 스파우스를 두거나, 1-3명의 부모가 혼자 있거나, 대가족이 당신과 함께 여행하는 것보다 가능성이 더 높다. 특색 간의 상관 관계1234sns.heatmap(data.corr(),annot=True,cmap='RdYlGn',linewidths=0.2) #data.corr()--&gt;상관 행렬fig=plt.gcf()fig.set_size_inches(10,8)plt.show()","link":"/2020/11/04/titanic/"},{"title":"home_credit_default_risk","text":"Kaggle API 설치 Google Colab에서 Kaggle API를 불러오려면 다음 소스코드를 실행한다. 1!pip install kaggle Requirement already satisfied: kaggle in /usr/local/lib/python3.6/dist-packages (1.5.9) Requirement already satisfied: requests in /usr/local/lib/python3.6/dist-packages (from kaggle) (2.23.0) Requirement already satisfied: slugify in /usr/local/lib/python3.6/dist-packages (from kaggle) (0.0.1) Requirement already satisfied: urllib3 in /usr/local/lib/python3.6/dist-packages (from kaggle) (1.24.3) Requirement already satisfied: tqdm in /usr/local/lib/python3.6/dist-packages (from kaggle) (4.41.1) Requirement already satisfied: python-slugify in /usr/local/lib/python3.6/dist-packages (from kaggle) (4.0.1) Requirement already satisfied: six&gt;=1.10 in /usr/local/lib/python3.6/dist-packages (from kaggle) (1.15.0) Requirement already satisfied: certifi in /usr/local/lib/python3.6/dist-packages (from kaggle) (2020.6.20) Requirement already satisfied: python-dateutil in /usr/local/lib/python3.6/dist-packages (from kaggle) (2.8.1) Requirement already satisfied: idna&lt;3,&gt;=2.5 in /usr/local/lib/python3.6/dist-packages (from requests-&gt;kaggle) (2.10) Requirement already satisfied: chardet&lt;4,&gt;=3.0.2 in /usr/local/lib/python3.6/dist-packages (from requests-&gt;kaggle) (3.0.4) Requirement already satisfied: text-unidecode&gt;=1.3 in /usr/local/lib/python3.6/dist-packages (from python-slugify-&gt;kaggle) (1.3) 1. Kaggle Token 다운로드 Kaggle에서 API Token을 다운로드 받는다. [Kaggle]-[My Account]-[API]-[Create New API Token]을 누르면 kaggle.json 파일이 다운로드 된다. 이 파일을 바탕화면에 옮긴 뒤, 아래 코드(토큰을 실행시키는 코드)를 실행 시킨다. 12345678from google.colab import filesuploaded = files.upload()for fn in uploaded.keys(): print('uploaded file &quot;{name}&quot; with length {length} bytes'.format( name=fn, length=len(uploaded[fn]))) # kaggle.json을 아래 폴더로 옮긴 뒤, file을 사용할 수 있도록 권한을 부여한다. !mkdir -p ~/.kaggle/ &amp;&amp; mv kaggle.json ~/.kaggle/ &amp;&amp; chmod 600 ~/.kaggle/kaggle.json Upload widget is only available when the cell has been executed in the current browser session. Please rerun this cell to enable. Saving kaggle.json to kaggle.json uploaded file &quot;kaggle.json&quot; with length 66 bytes 아래 코드는 실행됬는지 확인하는 코드 1ls -1ha ~/.kaggle/kaggle.json /root/.kaggle/kaggle.json 2. Kaggle 데이터 불러오기 먼저 kaggle competition list를 불러온다. 1!kaggle competitions list Warning: Looks like you're using an outdated API Version, please consider updating (server 1.5.9 / client 1.5.4) ref deadline category reward teamCount userHasEntered --------------------------------------------- ------------------- --------------- --------- --------- -------------- contradictory-my-dear-watson 2030-07-01 23:59:00 Getting Started Prizes 134 False gan-getting-started 2030-07-01 23:59:00 Getting Started Prizes 161 False tpu-getting-started 2030-06-03 23:59:00 Getting Started Knowledge 292 False digit-recognizer 2030-01-01 00:00:00 Getting Started Knowledge 2248 False titanic 2030-01-01 00:00:00 Getting Started Knowledge 17260 True house-prices-advanced-regression-techniques 2030-01-01 00:00:00 Getting Started Knowledge 4325 True connectx 2030-01-01 00:00:00 Getting Started Knowledge 366 False nlp-getting-started 2030-01-01 00:00:00 Getting Started Knowledge 1130 False rock-paper-scissors 2021-02-01 23:59:00 Playground Prizes 226 False riiid-test-answer-prediction 2021-01-07 23:59:00 Featured $100,000 1491 False nfl-big-data-bowl-2021 2021-01-05 23:59:00 Analytics $100,000 0 False competitive-data-science-predict-future-sales 2020-12-31 23:59:00 Playground Kudos 9392 False halite-iv-playground-edition 2020-12-31 23:59:00 Playground Knowledge 44 False predict-volcanic-eruptions-ingv-oe 2020-12-28 23:59:00 Playground Swag 198 False hashcode-drone-delivery 2020-12-14 23:59:00 Playground Knowledge 80 False cdp-unlocking-climate-solutions 2020-12-02 23:59:00 Analytics $91,000 0 False lish-moa 2020-11-30 23:59:00 Research $30,000 3454 False google-football 2020-11-30 23:59:00 Featured $6,000 925 False conways-reverse-game-of-life-2020 2020-11-30 23:59:00 Playground Swag 132 False lyft-motion-prediction-autonomous-vehicles 2020-11-25 23:59:00 Featured $30,000 788 False 1!kaggle competitions download -c home-credit-default-risk Warning: Looks like you're using an outdated API Version, please consider updating (server 1.5.9 / client 1.5.4) installments_payments.csv.zip: Skipping, found more recently modified local copy (use --force to force download) previous_application.csv.zip: Skipping, found more recently modified local copy (use --force to force download) application_test.csv.zip: Skipping, found more recently modified local copy (use --force to force download) bureau.csv.zip: Skipping, found more recently modified local copy (use --force to force download) sample_submission.csv: Skipping, found more recently modified local copy (use --force to force download) POS_CASH_balance.csv.zip: Skipping, found more recently modified local copy (use --force to force download) credit_card_balance.csv.zip: Skipping, found more recently modified local copy (use --force to force download) HomeCredit_columns_description.csv: Skipping, found more recently modified local copy (use --force to force download) application_train.csv.zip: Skipping, found more recently modified local copy (use --force to force download) bureau_balance.csv.zip: Skipping, found more recently modified local copy (use --force to force download) ls는 디렉터리(파일,경로) 내의 데이터 파일을 보여주는 명령어 1!ls application_test.csv.zip installments_payments.csv.zip application_train.csv.zip POS_CASH_balance.csv.zip bureau_balance.csv.zip previous_application.csv.zip bureau.csv.zip sample_data credit_card_balance.csv.zip sample_submission.csv gender_submission.csv test.csv HomeCredit_columns_description.csv train.csv 12345678! unzip application_test.csv.zip ! unzipinstallments_payments.csv.zip! unzip application_train.csv.zip ! unzip POS_CASH_balance.csv.zip! unzip bureau_balance.csv.zip ! unzip previous_application.csv.zip! unzip bureau.csv.zip ! unzip credit_card_balance.csv.zip Archive: application_test.csv.zip inflating: application_test.csv /bin/bash: unzipinstallments_payments.csv.zip: command not found Archive: application_train.csv.zip replace application_train.csv? [y]es, [n]o, [A]ll, [N]one, [r]ename: y inflating: application_train.csv Archive: POS_CASH_balance.csv.zip replace POS_CASH_balance.csv? [y]es, [n]o, [A]ll, [N]one, [r]ename: y inflating: POS_CASH_balance.csv Archive: bureau_balance.csv.zip replace bureau_balance.csv? [y]es, [n]o, [A]ll, [N]one, [r]ename: y inflating: bureau_balance.csv Archive: previous_application.csv.zip replace previous_application.csv? [y]es, [n]o, [A]ll, [N]one, [r]ename: y inflating: previous_application.csv Archive: bureau.csv.zip replace bureau.csv? [y]es, [n]o, [A]ll, [N]one, [r]ename: y inflating: bureau.csv Archive: credit_card_balance.csv.zip replace credit_card_balance.csv? [y]es, [n]o, [A]ll, [N]one, [r]ename: y inflating: credit_card_balance.csv 현재 총 14개의 데이터를 다운로드 받았다. application_test.csv.zip installments_payments.csv.zip application_train.csv.zip POS_CASH_balance.csv.zip bureau_balance.csv.zip previous_application.csv.zip bureau.csv.zip sample_data credit_card_balance.csv.zip sample_submission.csv gender_submission.csv test.csv HomeCredit_columns_description.csv train.csv 3. 캐글 데이터 수집 및 EDA 우선 데이터를 수집하기에 앞서서 EDA에 관한 필수 패키지를 설치하자. 12345678910111213# 데이터 조작을 위한 numpy와 팬더import numpy as npimport pandas as pd # 범주형 변수를 처리하기 위한 사전 처리 학습from sklearn.preprocessing import LabelEncoder# 파일 시스템 매니지먼트import os# 경고 억제import warningswarnings.filterwarnings('ignore')# 플롯을 위한 matplotlib 및 seaornimport matplotlib.pyplot as pltimport seaborn as sns 분류 감독됨: 라벨은 교육 데이터에 포함되며, 목적은 형상으로부터 라벨을 예측하는 방법을 학습하는 모델을 훈련시키는 것이다. 분류: 라벨은 0(대출금을 제때 상환할 수 있음), 1(대출금 상환에 어려움이 있음)의 이진 변수다. 데이터 : 은행을 이용하지 않은 사람들에게 신용대출(대출)을 제공하는 서비스인 홈 크레딧에 의해 제공된다 12# 사용 가능한 파일 나열print(os.listdir()) ['.config', 'previous_application.csv', 'application_train.csv', 'bureau_balance.csv', 'application_test.csv.zip', 'bureau.csv', 'POS_CASH_balance.csv', 'previous_application.csv.zip', 'bureau_balance.csv.zip', 'POS_CASH_balance.csv.zip', 'HomeCredit_columns_description.csv', 'bureau.csv.zip', 'installments_payments.csv.zip', 'test.csv', 'sample_submission.csv', 'application_train.csv.zip', 'gender_submission.csv', 'credit_card_balance.csv', 'credit_card_balance.csv.zip', 'train.csv', 'sample_data'] 1234# 교육자료app_train = pd.read_csv('application_train.csv')print('Training data shape: ', app_train.shape)app_train.head() Training data shape: (307511, 122) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } SK_ID_CURR TARGET NAME_CONTRACT_TYPE CODE_GENDER FLAG_OWN_CAR FLAG_OWN_REALTY CNT_CHILDREN AMT_INCOME_TOTAL AMT_CREDIT AMT_ANNUITY AMT_GOODS_PRICE NAME_TYPE_SUITE NAME_INCOME_TYPE NAME_EDUCATION_TYPE NAME_FAMILY_STATUS NAME_HOUSING_TYPE REGION_POPULATION_RELATIVE DAYS_BIRTH DAYS_EMPLOYED DAYS_REGISTRATION DAYS_ID_PUBLISH OWN_CAR_AGE FLAG_MOBIL FLAG_EMP_PHONE FLAG_WORK_PHONE FLAG_CONT_MOBILE FLAG_PHONE FLAG_EMAIL OCCUPATION_TYPE CNT_FAM_MEMBERS REGION_RATING_CLIENT REGION_RATING_CLIENT_W_CITY WEEKDAY_APPR_PROCESS_START HOUR_APPR_PROCESS_START REG_REGION_NOT_LIVE_REGION REG_REGION_NOT_WORK_REGION LIVE_REGION_NOT_WORK_REGION REG_CITY_NOT_LIVE_CITY REG_CITY_NOT_WORK_CITY LIVE_CITY_NOT_WORK_CITY ... LIVINGAPARTMENTS_MEDI LIVINGAREA_MEDI NONLIVINGAPARTMENTS_MEDI NONLIVINGAREA_MEDI FONDKAPREMONT_MODE HOUSETYPE_MODE TOTALAREA_MODE WALLSMATERIAL_MODE EMERGENCYSTATE_MODE OBS_30_CNT_SOCIAL_CIRCLE DEF_30_CNT_SOCIAL_CIRCLE OBS_60_CNT_SOCIAL_CIRCLE DEF_60_CNT_SOCIAL_CIRCLE DAYS_LAST_PHONE_CHANGE FLAG_DOCUMENT_2 FLAG_DOCUMENT_3 FLAG_DOCUMENT_4 FLAG_DOCUMENT_5 FLAG_DOCUMENT_6 FLAG_DOCUMENT_7 FLAG_DOCUMENT_8 FLAG_DOCUMENT_9 FLAG_DOCUMENT_10 FLAG_DOCUMENT_11 FLAG_DOCUMENT_12 FLAG_DOCUMENT_13 FLAG_DOCUMENT_14 FLAG_DOCUMENT_15 FLAG_DOCUMENT_16 FLAG_DOCUMENT_17 FLAG_DOCUMENT_18 FLAG_DOCUMENT_19 FLAG_DOCUMENT_20 FLAG_DOCUMENT_21 AMT_REQ_CREDIT_BUREAU_HOUR AMT_REQ_CREDIT_BUREAU_DAY AMT_REQ_CREDIT_BUREAU_WEEK AMT_REQ_CREDIT_BUREAU_MON AMT_REQ_CREDIT_BUREAU_QRT AMT_REQ_CREDIT_BUREAU_YEAR 0 100002 1 Cash loans M N Y 0 202500.0 406597.5 24700.5 351000.0 Unaccompanied Working Secondary / secondary special Single / not married House / apartment 0.018801 -9461 -637 -3648.0 -2120 NaN 1 1 0 1 1 0 Laborers 1.0 2 2 WEDNESDAY 10 0 0 0 0 0 0 ... 0.0205 0.0193 0.0000 0.00 reg oper account block of flats 0.0149 Stone, brick No 2.0 2.0 2.0 2.0 -1134.0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.0 0.0 0.0 0.0 0.0 1.0 1 100003 0 Cash loans F N N 0 270000.0 1293502.5 35698.5 1129500.0 Family State servant Higher education Married House / apartment 0.003541 -16765 -1188 -1186.0 -291 NaN 1 1 0 1 1 0 Core staff 2.0 1 1 MONDAY 11 0 0 0 0 0 0 ... 0.0787 0.0558 0.0039 0.01 reg oper account block of flats 0.0714 Block No 1.0 0.0 1.0 0.0 -828.0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.0 0.0 0.0 0.0 0.0 0.0 2 100004 0 Revolving loans M Y Y 0 67500.0 135000.0 6750.0 135000.0 Unaccompanied Working Secondary / secondary special Single / not married House / apartment 0.010032 -19046 -225 -4260.0 -2531 26.0 1 1 1 1 1 0 Laborers 1.0 2 2 MONDAY 9 0 0 0 0 0 0 ... NaN NaN NaN NaN NaN NaN NaN NaN NaN 0.0 0.0 0.0 0.0 -815.0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.0 0.0 0.0 0.0 0.0 0.0 3 100006 0 Cash loans F N Y 0 135000.0 312682.5 29686.5 297000.0 Unaccompanied Working Secondary / secondary special Civil marriage House / apartment 0.008019 -19005 -3039 -9833.0 -2437 NaN 1 1 0 1 0 0 Laborers 2.0 2 2 WEDNESDAY 17 0 0 0 0 0 0 ... NaN NaN NaN NaN NaN NaN NaN NaN NaN 2.0 0.0 2.0 0.0 -617.0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 NaN NaN NaN NaN NaN NaN 4 100007 0 Cash loans M N Y 0 121500.0 513000.0 21865.5 513000.0 Unaccompanied Working Secondary / secondary special Single / not married House / apartment 0.028663 -19932 -3038 -4311.0 -3458 NaN 1 1 0 1 0 0 Core staff 1.0 2 2 THURSDAY 11 0 0 0 0 1 1 ... NaN NaN NaN NaN NaN NaN NaN NaN NaN 0.0 0.0 0.0 0.0 -1106.0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0.0 0.0 0.0 0.0 0.0 0.0 5 rows × 122 columns 교육 데이터에는 307511개의 관측치(각각 별도 대출)와 대상(우리가 예측하고자 하는 라벨)을 포함한 122개의 특징(변수)이 있다. 1234# 데이터 기능 테스트app_test = pd.read_csv('application_test.csv')print('Testing data shape: ', app_test.shape)app_test.head() Testing data shape: (48744, 121) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } SK_ID_CURR NAME_CONTRACT_TYPE CODE_GENDER FLAG_OWN_CAR FLAG_OWN_REALTY CNT_CHILDREN AMT_INCOME_TOTAL AMT_CREDIT AMT_ANNUITY AMT_GOODS_PRICE NAME_TYPE_SUITE NAME_INCOME_TYPE NAME_EDUCATION_TYPE NAME_FAMILY_STATUS NAME_HOUSING_TYPE REGION_POPULATION_RELATIVE DAYS_BIRTH DAYS_EMPLOYED DAYS_REGISTRATION DAYS_ID_PUBLISH OWN_CAR_AGE FLAG_MOBIL FLAG_EMP_PHONE FLAG_WORK_PHONE FLAG_CONT_MOBILE FLAG_PHONE FLAG_EMAIL OCCUPATION_TYPE CNT_FAM_MEMBERS REGION_RATING_CLIENT REGION_RATING_CLIENT_W_CITY WEEKDAY_APPR_PROCESS_START HOUR_APPR_PROCESS_START REG_REGION_NOT_LIVE_REGION REG_REGION_NOT_WORK_REGION LIVE_REGION_NOT_WORK_REGION REG_CITY_NOT_LIVE_CITY REG_CITY_NOT_WORK_CITY LIVE_CITY_NOT_WORK_CITY ORGANIZATION_TYPE ... LIVINGAPARTMENTS_MEDI LIVINGAREA_MEDI NONLIVINGAPARTMENTS_MEDI NONLIVINGAREA_MEDI FONDKAPREMONT_MODE HOUSETYPE_MODE TOTALAREA_MODE WALLSMATERIAL_MODE EMERGENCYSTATE_MODE OBS_30_CNT_SOCIAL_CIRCLE DEF_30_CNT_SOCIAL_CIRCLE OBS_60_CNT_SOCIAL_CIRCLE DEF_60_CNT_SOCIAL_CIRCLE DAYS_LAST_PHONE_CHANGE FLAG_DOCUMENT_2 FLAG_DOCUMENT_3 FLAG_DOCUMENT_4 FLAG_DOCUMENT_5 FLAG_DOCUMENT_6 FLAG_DOCUMENT_7 FLAG_DOCUMENT_8 FLAG_DOCUMENT_9 FLAG_DOCUMENT_10 FLAG_DOCUMENT_11 FLAG_DOCUMENT_12 FLAG_DOCUMENT_13 FLAG_DOCUMENT_14 FLAG_DOCUMENT_15 FLAG_DOCUMENT_16 FLAG_DOCUMENT_17 FLAG_DOCUMENT_18 FLAG_DOCUMENT_19 FLAG_DOCUMENT_20 FLAG_DOCUMENT_21 AMT_REQ_CREDIT_BUREAU_HOUR AMT_REQ_CREDIT_BUREAU_DAY AMT_REQ_CREDIT_BUREAU_WEEK AMT_REQ_CREDIT_BUREAU_MON AMT_REQ_CREDIT_BUREAU_QRT AMT_REQ_CREDIT_BUREAU_YEAR 0 100001 Cash loans F N Y 0 135000.0 568800.0 20560.5 450000.0 Unaccompanied Working Higher education Married House / apartment 0.018850 -19241 -2329 -5170.0 -812 NaN 1 1 0 1 0 1 NaN 2.0 2 2 TUESDAY 18 0 0 0 0 0 0 Kindergarten ... NaN 0.0514 NaN NaN NaN block of flats 0.0392 Stone, brick No 0.0 0.0 0.0 0.0 -1740.0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.0 0.0 0.0 0.0 0.0 0.0 1 100005 Cash loans M N Y 0 99000.0 222768.0 17370.0 180000.0 Unaccompanied Working Secondary / secondary special Married House / apartment 0.035792 -18064 -4469 -9118.0 -1623 NaN 1 1 0 1 0 0 Low-skill Laborers 2.0 2 2 FRIDAY 9 0 0 0 0 0 0 Self-employed ... NaN NaN NaN NaN NaN NaN NaN NaN NaN 0.0 0.0 0.0 0.0 0.0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.0 0.0 0.0 0.0 0.0 3.0 2 100013 Cash loans M Y Y 0 202500.0 663264.0 69777.0 630000.0 NaN Working Higher education Married House / apartment 0.019101 -20038 -4458 -2175.0 -3503 5.0 1 1 0 1 0 0 Drivers 2.0 2 2 MONDAY 14 0 0 0 0 0 0 Transport: type 3 ... NaN NaN NaN NaN NaN NaN NaN NaN NaN 0.0 0.0 0.0 0.0 -856.0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0.0 0.0 0.0 0.0 1.0 4.0 3 100028 Cash loans F N Y 2 315000.0 1575000.0 49018.5 1575000.0 Unaccompanied Working Secondary / secondary special Married House / apartment 0.026392 -13976 -1866 -2000.0 -4208 NaN 1 1 0 1 1 0 Sales staff 4.0 2 2 WEDNESDAY 11 0 0 0 0 0 0 Business Entity Type 3 ... 0.2446 0.3739 0.0388 0.0817 reg oper account block of flats 0.3700 Panel No 0.0 0.0 0.0 0.0 -1805.0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.0 0.0 0.0 0.0 0.0 3.0 4 100038 Cash loans M Y N 1 180000.0 625500.0 32067.0 625500.0 Unaccompanied Working Secondary / secondary special Married House / apartment 0.010032 -13040 -2191 -4000.0 -4262 16.0 1 1 1 1 0 0 NaN 3.0 2 2 FRIDAY 5 0 0 0 0 1 1 Business Entity Type 3 ... NaN NaN NaN NaN NaN NaN NaN NaN NaN 0.0 0.0 0.0 0.0 -821.0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 NaN NaN NaN NaN NaN NaN 5 rows × 121 columns 테스트 세트가 상당히 작고 대상 컬럼이 부족하다. 탐색적 데이터 분석.탐색적 데이터 분석(EDA)은 우리가 통계를 계산하고 수치를 만들어 데이터 내의 경향, 이상 징후, 패턴 또는 관계를 찾아내는 개방형 프로세스다. EDA의 목표는 우리의 데이터가 우리에게 말해줄 수 있는 것을 배우는 것이다. 일반적으로 높은 수준의 개요에서 시작되며, 데이터에서 흥미로운 영역을 발견하면 특정 영역으로 좁혀진다. 그 결과들은 그 자체로 흥미로울 수도 있고, 어떤 기능을 사용할지 결정하는 것을 도와줌으로써 우리의 모델 선택을 알리는 데 사용될 수도 있다. 대상 열의 분포 조사대상은 대출금 0을 제때 상환했거나 고객이 상환에 어려움을 겪었음을 나타내는 1을 예측하라는 것이다. 우리는 우선 각 범주에 속하는 대출의 수를 조사할 수 있다. 1app_train['TARGET'].value_counts() 0 282686 1 24825 Name: TARGET, dtype: int64 1app_train['TARGET'].astype(int).plot.hist(); 이 정보로부터, 우리는 이것이 불균형한 계급 문제임을 알 수 있다. 제때 갚지 못한 대출보다 제때 갚은 대출이 훨씬 많다. 일단 우리가 좀 더 정교한 기계 학습 모델에 들어가면, 우리는 이러한 불균형을 반영하기 위해 데이터에서의 그들의 표현에 따라 수업에 무게를 둘 수 있다. 결측값 검사다음으로 각 열에 있는 결측값의 수와 백분율을 살펴보기로 한다. 123456789101112131415161718192021222324252627# 결측값을 열로 계산하는 함수 #Funct def missing_values_table(df): # 결측값 합계 mis_val = df.isnull().sum() # 결측값 백분율 mis_val_percent = 100 * df.isnull().sum() / len(df) # 결과로 테이블 만들기 mis_val_table = pd.concat([mis_val, mis_val_percent], axis=1) # 열 이름 바꾸기 mis_val_table_ren_columns = mis_val_table.rename( columns = {0 : 'Missing Values', 1 : '% of Total Values'}) # 누락된 내림차순 백분율을 기준으로 테이블 정렬 mis_val_table_ren_columns = mis_val_table_ren_columns[ mis_val_table_ren_columns.iloc[:,1] != 0].sort_values( '% of Total Values', ascending=False).round(1) # 일부 요약 정보 인쇄 print (&quot;Your selected dataframe has &quot; + str(df.shape[1]) + &quot; columns.\\n&quot; &quot;There are &quot; + str(mis_val_table_ren_columns.shape[0]) + &quot; columns that have missing values.&quot;) # 누락된 정보가 있는 데이터 프레임 반환 return mis_val_table_ren_columns 123# 결측값 통계량missing_values = missing_values_table(app_train)missing_values.head(20) Your selected dataframe has 122 columns. There are 67 columns that have missing values. .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Missing Values % of Total Values COMMONAREA_MEDI 214865 69.9 COMMONAREA_AVG 214865 69.9 COMMONAREA_MODE 214865 69.9 NONLIVINGAPARTMENTS_MEDI 213514 69.4 NONLIVINGAPARTMENTS_MODE 213514 69.4 NONLIVINGAPARTMENTS_AVG 213514 69.4 FONDKAPREMONT_MODE 210295 68.4 LIVINGAPARTMENTS_MODE 210199 68.4 LIVINGAPARTMENTS_MEDI 210199 68.4 LIVINGAPARTMENTS_AVG 210199 68.4 FLOORSMIN_MODE 208642 67.8 FLOORSMIN_MEDI 208642 67.8 FLOORSMIN_AVG 208642 67.8 YEARS_BUILD_MODE 204488 66.5 YEARS_BUILD_MEDI 204488 66.5 YEARS_BUILD_AVG 204488 66.5 OWN_CAR_AGE 202929 66.0 LANDAREA_AVG 182590 59.4 LANDAREA_MEDI 182590 59.4 LANDAREA_MODE 182590 59.4 열 유형각 데이터 유형의 열 수를 살펴보자. int64와 float64는 숫자 변수(이산형 또는 연속형일 수 있음)이다. 객체 열은 문자열을 포함하며 범주형 형상이다. 12# 각 열 유형별 수app_train.dtypes.value_counts() float64 65 int64 41 object 16 dtype: int64 이제 각 개체(범주형) 열에 있는 고유한 항목 수를 살펴봅시다. 12# 각 객체 열의 고유 클래스 수app_train.select_dtypes('object').apply(pd.Series.nunique, axis = 0) NAME_CONTRACT_TYPE 2 CODE_GENDER 3 FLAG_OWN_CAR 2 FLAG_OWN_REALTY 2 NAME_TYPE_SUITE 7 NAME_INCOME_TYPE 8 NAME_EDUCATION_TYPE 5 NAME_FAMILY_STATUS 6 NAME_HOUSING_TYPE 6 OCCUPATION_TYPE 18 WEEKDAY_APPR_PROCESS_START 7 ORGANIZATION_TYPE 58 FONDKAPREMONT_MODE 4 HOUSETYPE_MODE 3 WALLSMATERIAL_MODE 7 EMERGENCYSTATE_MODE 2 dtype: int64 대부분의 범주형 변수의 고유 항목 수는 상대적으로 적다. 우리는 이러한 범주형 변수에 대처할 방법을 찾아야 할 것이다! 범주형 변수를 인코딩하는 중:더 나아가기 전에 성가신 범주형 변수를 다뤄야 한다. 기계 학습 모델은 유감스럽게도 범주형 변수를 다룰 수 없다(LightGBM과 같은 일부 모델은 제외). 따라서 이 변수들을 모델로 넘기기 전에 숫자로 인코딩(표현)하는 방법을 찾아야 한다. 이 과정을 수행하는 방법에는 크게 두 가지가 있다. 라벨 인코딩: 정수를 사용하여 범주형 변수의 각 고유 범주를 할당하십시오. 새 열이 생성되지 않음 예는 아래와 같다. 단일 핫 인코딩: 범주형 변수의 각 고유 범주에 대해 새 열을 생성하십시오. 각 관측치는 해당 범주에 대해 열에 1을, 다른 모든 새 열에 0을 받는다. 라벨 인코딩의 문제는 카테고리에 임의의 순서를 부여한다는 것이다. 각 범주에 할당된 값은 랜덤이며 범주의 고유한 측면을 반영하지 않는다. 위의 예에서 프로그래머는 4를, 데이터 과학자는 1을 받지만, 만약 우리가 같은 과정을 다시 한다면, 라벨이 거꾸로 되거나 완전히 달라질 수 있다. 정수의 실제 할당은 임의적이다. 따라서 우리가 라벨 인코딩을 수행할 때 모델은 형상의 상대적 값(예: 프로그래머 = 4 및 데이터 과학자 = 1)을 사용하여 우리가 원하는 가중치를 할당할 수 있다. 범주형 변수(예: 남성/여성)에 대해 고유한 값이 두 개뿐이면 레이블 인코딩은 괜찮지만 두 개 이상의 고유한 범주에 대해서는 하나의 핫 인코딩이 안전한 옵션이다. 이러한 접근방식의 상대적 장점에 대해 일부 논쟁이 있으며, 일부 모델은 라벨로 인코딩된 범주형 변수를 문제 없이 다룰 수 있다. 여기 좋은 스택 오버플로 토론이 있다. 클래스가 많은 범주형 변수에 대해서는 (그리고 이것은 개인적인 의견일 뿐이다) 하나의 핫 인코딩이 범주에 임의의 값을 부과하지 않기 때문에 가장 안전한 접근법이라고 생각한다. 단일 핫 인코딩의 유일한 단점은 피쳐 수(데이터의 치수)가 범주가 많은 범주형 변수로 폭발할 수 있다는 점이다. 이를 처리하기 위해 PCA나 기타 차원성 감소 방법에 따라 1회 핫 인코딩을 수행하여 치수 수를 줄일 수 있다(여전히 정보 보존을 위해 노력). 이 노트북에서는 범주 2개만 있는 범주형 변수에 레이블 인코딩을 사용하고 범주 2개 이상의 범주형 변수에 대해 One-Hot 인코딩을 사용할 것이다. 이 과정은 프로젝트에 더 깊이 들어가면서 변화가 필요할 수 있지만, 현재로서는 이것이 우리에게 어떤 영향을 미치는지 알 수 있을 것이다. (우리는 또한 이 노트북에서 어떠한 차원성 감소도 사용하지 않고 향후 반복해서 검토할 것이다.) 레이블 인코딩 및 단일 핫 인코딩위에서 설명한 정책을 실행하자: 2개의 고유한 범주를 가진 범주형 변수(dtype == 객체)에 대해서는 레이블 인코딩을 사용하고, 2개 이상의 고유한 범주를 가진 범주형 변수에 대해서는 1-hot 인코딩을 사용한다. 라벨 인코딩의 경우 Scikit-Learn LabelEncoder를 사용하고, 핫 인코딩의 경우 팬더 get_dummies(df) 기능을 사용한다. 12345678910111213141516171819# 레이블 인코더 객체 생성le = LabelEncoder()le_count = 0# 열을 반복하십시오for col in app_train: if app_train[col].dtype == 'object': # 고유 범주가 2개 이하인 경우 if len(list(app_train[col].unique())) &lt;= 2: # 교육 데이터 교육 le.fit(app_train[col]) # 교육 및 테스트 데이터 모두 혁신 app_train[col] = le.transform(app_train[col]) app_test[col] = le.transform(app_test[col]) # 레이블이 인코딩된 열 수를 추적 le_count += 1 print('%d columns were label encoded.' % le_count) 0 columns were label encoded. 123456# 범주형 변수의 단일 핫 인코딩app_train = pd.get_dummies(app_train)app_test = pd.get_dummies(app_test)print('Training Features shape: ', app_train.shape)print('Testing Features shape: ', app_test.shape) Training Features shape: (307511, 243) Testing Features shape: (48744, 239) 교육 및 테스트 데이터 정렬훈련 데이터와 시험 데이터 모두에서 동일한 특징(색상)이 있어야 한다. 원핫 인코딩은 시험 데이터에 나타나지 않는 범주를 포함하는 일부 범주형 변수가 있었기 때문에 훈련 데이터에 더 많은 열을 생성했다. 테스트 데이터에 없는 교육 데이터 열을 제거하려면 데이터 프레임을 정렬해야 한다. 먼저 교육 데이터에서 대상 열을 추출한다(시험 데이터에는 없지만 이 정보를 보관해야 하기 때문이다). 정렬을 수행할 때 행이 아닌 열에 따라 데이터 프레임을 정렬하도록 축 = 1을 설정해야 함! 12345678910train_labels = app_train['TARGET']# 교육 및 테스트 데이터 정렬, 두 데이터 프레임에 열만 유지app_train, app_test = app_train.align(app_test, join = 'inner', axis = 1)# 목표값 다시 추가app_train['TARGET'] = train_labelsprint('Training Features shape: ', app_train.shape)print('Testing Features shape: ', app_test.shape) Training Features shape: (307511, 240) Testing Features shape: (48744, 239) 교육 및 테스트 데이터셋은 이제 머신러닝에 필요한 기능과 동일한 기능을 가지고 있다. 원핫 인코딩으로 피쳐 수가 크게 늘었다. 데이터셋 크기를 줄이기 위해 언젠가는 차원성 축소(관련되지 않은 기능 제거)를 시도해보려고 할 것이다. 탐색 데이터 분석으로 돌아가기이상 징후우리가 EDA를 할 때 항상 경계하고 싶은 한 가지 문제는 데이터 내의 이상 현상이다. 이는 잘못된 형식의 숫자, 측정 장비의 오류 또는 유효하지만 극단적인 측정 때문일 수 있다. 이상 징후를 정량적으로 지원하는 한 가지 방법은 설명 방법을 사용하여 열의 통계를 보는 것이다. DAYS_BOYDE 칼럼의 숫자는 현재 대출 신청과 관련하여 기록되기 때문에 음수가 된다. 이러한 통계치를 년 단위로 보려면 -1로 나누어 1년 내 일수로 나누면 된다. 1(app_train['DAYS_BIRTH'] / -365).describe() count 307511.000000 mean 43.936973 std 11.956133 min 20.517808 25% 34.008219 50% 43.150685 75% 53.923288 max 69.120548 Name: DAYS_BIRTH, dtype: float64 그 나이들은 합리적으로 보인다. 높은 쪽이든 낮은 쪽이든 나이에 대한 특이치는 없다. 1app_train['DAYS_EMPLOYED'].describe() count 307511.000000 mean 63815.045904 std 141275.766519 min -17912.000000 25% -2760.000000 50% -1213.000000 75% -289.000000 max 365243.000000 Name: DAYS_EMPLOYED, dtype: float64 그건 옳지 않아! 최대값(긍정적인 것 외에)은 약 1000년 12app_train['DAYS_EMPLOYED'].plot.hist(title = 'Days Employment Histogram');plt.xlabel('Days Employment'); 그냥 궁금해서 변칙적인 고객들을 부분집합해서 나머지 고객들보다 채무불이행 비율이 더 높은지 낮은지 살펴보자. 12345anom = app_train[app_train['DAYS_EMPLOYED'] == 365243]non_anom = app_train[app_train['DAYS_EMPLOYED'] != 365243]print('The non-anomalies default on %0.2f%% of loans' % (100 * non_anom['TARGET'].mean()))print('The anomalies default on %0.2f%% of loans' % (100 * anom['TARGET'].mean()))print('There are %d anomalous days of employment' % len(anom)) The non-anomalies default on 8.66% of loans The anomalies default on 5.40% of loans There are 55374 anomalous days of employment 이상 징후는 채무불이행 비율이 낮은 것으로 나타났다. 이상 징후를 다루는 것은 정해진 규칙 없이 정확한 상황에 따라 달라진다. 가장 안전한 방법 중 하나는 기계의 학습 전에 이상 징후를 결측값으로 설정한 다음 (귀책 사용) 입력하는 것이다. 이 경우 모든 이상 징후가 정확히 동일한 가치를 가지기 때문에 이러한 모든 대출이 공통적으로 공유될 경우에 대비하여 동일한 가치로 기입하고자 한다. 변칙적인 값들은 어느 정도 중요한 것 같아, 만약 우리가 실제로 이 값을 채웠다면 우리는 기계 학습 모델을 말해주고 싶다. 해결책으로 숫자(np.nan)가 아닌 변칙값으로 채운 다음 변칙값의 변칙 여부를 나타내는 부울란을 새로 만들겠다. 12345678# 변칙적인 플래그 열 생성app_train['DAYS_EMPLOYED_ANOM'] = app_train[&quot;DAYS_EMPLOYED&quot;] == 365243# 변칙적인 값은 nan으로 대체app_train['DAYS_EMPLOYED'].replace({365243: np.nan}, inplace = True)app_train['DAYS_EMPLOYED'].plot.hist(title = 'Days Employment Histogram');plt.xlabel('Days Employment'); 분포는 우리가 예상할 수 있는 것과 훨씬 일치하는 것으로 보이며, 우리는 또한 모형에 이 값들이 원래 변칙적이라는 것을 알리기 위해 새로운 열을 만들었다. (왜냐하면 우리는 일부 값, 아마도 열의 중간값으로 난을 채워야 할 것이기 때문이다.) 데이터 프레임에 Days가 있는 다른 열은 명백한 특이치가 없는 것으로 우리가 기대하는 것에 대한 것으로 보인다. 매우 중요한 사항으로서, 교육 데이터에 대해 수행하는 모든 작업은 테스트 데이터에도 적용되어야 한다. 반드시 새 열을 만들고 기존 열을 테스트 데이터에 np.nan으로 채우자. 1234app_test['DAYS_EMPLOYED_ANOM'] = app_test[&quot;DAYS_EMPLOYED&quot;] == 365243app_test[&quot;DAYS_EMPLOYED&quot;].replace({365243: np.nan}, inplace = True)print('There are %d anomalies in the test data out of %d entries' % (app_test[&quot;DAYS_EMPLOYED_ANOM&quot;].sum(), len(app_test))) There are 9274 anomalies in the test data out of 48744 entries 상관 관계이제 범주형 변수와 특이치를 다루었으므로 EDA를 계속 진행합시다. 데이터를 이해하고 이해하는 한 가지 방법은 피쳐와 대상 간의 상관 관계를 찾는 것이다. 우리는 .corr 데이터프레임 방법을 사용하여 모든 변수와 목표값 사이의 Pearson 상관 계수를 계산할 수 있다. 상관 계수는 형상의 “관련성”을 나타내는 가장 큰 방법은 아니지만, 데이터 내에서 가능한 관계에 대한 아이디어를 제공한다. 상관관계의 절대값에 대한 일반적인 해석은 다음과 같다. .00-19 “매우 약함” .20-.39 “weak” .40-.59 “moderate” .60-.79 “강력” .80-1.0 “매우 강함” 123456# 대상과의 상관관계를 찾아 정렬correlations = app_train.corr()['TARGET'].sort_values()# 상관관계 표시print('Most Positive Correlations:\\n', correlations.tail(15))print('\\nMost Negative Correlations:\\n', correlations.head(15)) Most Positive Correlations: OCCUPATION_TYPE_Laborers 0.043019 FLAG_DOCUMENT_3 0.044346 REG_CITY_NOT_LIVE_CITY 0.044395 FLAG_EMP_PHONE 0.045982 NAME_EDUCATION_TYPE_Secondary / secondary special 0.049824 REG_CITY_NOT_WORK_CITY 0.050994 DAYS_ID_PUBLISH 0.051457 CODE_GENDER_M 0.054713 DAYS_LAST_PHONE_CHANGE 0.055218 NAME_INCOME_TYPE_Working 0.057481 REGION_RATING_CLIENT 0.058899 REGION_RATING_CLIENT_W_CITY 0.060893 DAYS_EMPLOYED 0.074958 DAYS_BIRTH 0.078239 TARGET 1.000000 Name: TARGET, dtype: float64 Most Negative Correlations: EXT_SOURCE_3 -0.178919 EXT_SOURCE_2 -0.160472 EXT_SOURCE_1 -0.155317 NAME_EDUCATION_TYPE_Higher education -0.056593 CODE_GENDER_F -0.054704 NAME_INCOME_TYPE_Pensioner -0.046209 DAYS_EMPLOYED_ANOM -0.045987 ORGANIZATION_TYPE_XNA -0.045987 FLOORSMAX_AVG -0.044003 FLOORSMAX_MEDI -0.043768 FLOORSMAX_MODE -0.043226 EMERGENCYSTATE_MODE_No -0.042201 HOUSETYPE_MODE_block of flats -0.040594 AMT_GOODS_PRICE -0.039645 REGION_POPULATION_RELATIVE -0.037227 Name: TARGET, dtype: float64 더 중요한 상관관계 몇 가지를 살펴봅시다: DAYS_BOYT는 가장 긍정적인 상관관계 입니다. (변수와 그 자체와의 상관관계가 항상 1이기 때문에 TARGET은 제외) 문서를 보면 Days_BOYT는 마이너스일(어떠한 이유로든!) 대출 당시 고객의 일(일) 연령이다. 상관관계는 양수지만, 이 특성의 값은 실제로 음수인데, 이는 클라이언트가 나이가 들수록 대출금 채무불이행(대상 == 0) 가능성이 적다는 것을 의미한다. 그건 좀 헷갈리니까 형상의 절대값을 취해서 그 다음에 상관관계는 음수가 될 겁니다. 상환연령이 상환에 미치는 영향123# 출생 후 양일간과 대상의 상관관계 찾기app_train['DAYS_BIRTH'] = abs(app_train['DAYS_BIRTH'])app_train['DAYS_BIRTH'].corr(app_train['TARGET']) -0.07823930830982694 고객이 나이가 들수록 고객이 나이가 들수록 대출금을 제때 상환하는 경향이 있다는 목표와 부정적인 선형 관계가 형성된다. 이 변수부터 살펴보자. 첫째, 우리는 시대의 히스토그램을 만들 수 있다. 우리는 그 줄거리를 좀 더 이해할 수 있도록 몇 년 안에 x축을 넣을 것이다. 123456# 플롯 스타일 설정plt.style.use('fivethirtyeight')# 연령별 연령 분포 그림 그리기plt.hist(app_train['DAYS_BIRTH'] / 365, edgecolor = 'k', bins = 25)plt.title('Age of Client'); plt.xlabel('Age (years)'); plt.ylabel('Count'); 그 자체로 연령의 분포는 모든 연령대가 합리적이기 때문에 특이치가 없다는 것 이외에는 우리에게 별로 알려주지 않는다. 연령대가 대상에 미치는 영향을 시각화하기 위해 다음으로 대상의 값으로 색칠한 KDE(커널 밀도 추정도)를 만들겠다. 커널 밀도 추정 그림은 단일 변수의 분포를 보여주며 평활 히스토그램으로 생각할 수 있다(대개 가우스인 커널을 각 데이터 지점에서 계산한 다음 모든 개별 커널을 평균하여 단일 평활 곡선을 개발함으로써 생성된다). 우리는 이 그래프에 해저 Kdeplot을 사용할 것이다. 12345678910plt.figure(figsize = (10, 8))# 제때 상환된 대출의 KDE 플롯sns.kdeplot(app_train.loc[app_train['TARGET'] == 0, 'DAYS_BIRTH'] / 365, label = 'target == 0')# 제때 상환되지 않은 대출의 KDE 플롯sns.kdeplot(app_train.loc[app_train['TARGET'] == 1, 'DAYS_BIRTH'] / 365, label = 'target == 1')# 플롯의 라벨링plt.xlabel('Age (years)'); plt.ylabel('Density'); plt.title('Distribution of Ages'); 목표 == 1 커브가 범위의 젊은 쪽 끝을 향해 기울어진다. 이는 유의미한 상관 계수(-0.07 상관 계수)는 아니지만, 이 변수는 대상에 영향을 미치기 때문에 머신러닝 모델에서 유용할 것으로 보인다. 이 관계를 다른 방식으로 보자: 평균적으로 연령대별 대출금 상환 실패. 이 그래프를 만들기 위해 먼저 나이 범주를 각각 5년씩의 빈으로 자른다. 그런 다음 각 빈에 대해 대상의 평균가치를 산출하는데, 이는 각 연령 범주별로 상환되지 않은 대출의 비율을 알려준다.","link":"/2020/11/05/home_credit_default_risk/"},{"title":"Seaborn with Matplotlib (1)","text":"1. seaborn + matplotlib seaborn을 matplotlib과 섞어쓰는 방법입니다. 4부 중 첫 번째 시간입니다. seaborn 함수 중 matplotlib axes를 반환하는 함수들에 관한 내용입니다. seaborn API seaborn은 matplotlib을 쉽고 아름답게 쓰고자 만들어졌습니다. 따라서 seaborn의 결과물은 당연히 matplotlib의 결과물입니다. 그러나 간혹 seaborn이 그린 그림의 폰트, 색상에 접근이 되지 않아 난처합니다. seaborn의 구조를 잘 이해하지 못하면 해결도 어렵습니다. v0.11 기준으로 seaborn에는 다음 함수들이 있습니다. matplotlib의 출력물은 figure와 axes만을 반환합니다. seaborn의 명령어 중 axes를 반환하는 것들은 matplotlib과 섞어 쓰기 좋습니다. 먼저 matplotlib의 객체 지향object oriented interface를 사용해서 그림의 틀을 만든 뒤, 특정 axes에 seaborn을 삽입하면 됩니다. 결론적으로, 하고 싶은 거 다 됩니다. 1.1. Load data 예제로 사용할 펭귄 데이터를 불러옵니다. seaborn에 내장되어 있습니다.123456import pandas as pdimport matplotlib.pyplot as pltimport seaborn as snspenguins = sns.load_dataset(&quot;penguins&quot;)penguins.head() 1.2. figure and axes matplotlib으로 도화지figure를 깔고 축공간axes를 만듭니다. 1 x 2 축공간을 구성합니다. 123fig, axes = plt.subplots(ncols=2, figsize=(8,4))fig.tight_layout() 1.3. plot with matplotlib matplotlib 기능을 이용해서 산점도를 그립니다. x축은 부리 길이 bill length y축은 부리 위 아래 두께 bill depth 색상은 종species로 합니다. Adelie, Chinstrap, Gentoo이 있습니다. 두 축공간 중 왼쪽에만 그립니다. 123456789101112131415fig, axes = plt.subplots(ncols=2, figsize=(8, 4))species_u = penguins[&quot;species&quot;].unique()# plot 0 : matplotlibfor i, s in enumerate(species_u): axes[0].scatter(penguins[&quot;bill_length_mm&quot;].loc[penguins[&quot;species&quot;]==s], penguins[&quot;bill_depth_mm&quot;].loc[penguins[&quot;species&quot;]==s], c=f&quot;C{i}&quot;, label=s, alpha=0.3 )axes[0].legend(species_u, title=&quot;species&quot;)axes[0].set_xlabel(&quot;Bill Length (mm)&quot;)axes[0].set_ylabel(&quot;Bill Depth (mm)&quot;)fig.tight_layout() 1.4. plot with seabornseaborn scatterplot 이번엔 같은 plot을 seaborn으로 그려봅니다. 위 코드에 아래 세 줄만 추가합니다. 1234# plot 1 : seabornsns.scatterplot(&quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;, hue=&quot;species&quot;, data=penguins, alpha=0.3, ax=axes[1])axes[1].set_xlabel(&quot;Bill Length (mm)&quot;)axes[1].set_ylabel(&quot;Bill Depth (mm)&quot;) 세 줄로 거의 동일한 그림이 나왔습니다. scatter plot의 점 크기만 살짝 작습니다. label의 투명도만 살짝 다릅니다. seaborn 명령 scatterplot()을 그대로 사용했습니다. x축과 y축 label도 바꾸었습니다. ax=axes[1] 인자에서 볼 수 있듯, 존재하는 axes에 그림만 얹었습니다. matplotlib 틀 + seaborn 그림 이므로, matplotlib 명령이 모두 통합니다. 1.5. matplotlib + seaborn &amp; seaborn + matplotlib matplotlib과 seaborn이 자유롭게 섞일 수 있습니다. matplotlib 산점도 위에 seaborn 추세선을 얹을 수 있고, seaborn 산점도 위에 matplotlib 중심점을 얹을 수 있습니다. 파이썬 코드는 다음과 같습니다. 12345678910111213141516171819202122232425262728293031323334fig, axes = plt.subplots(ncols=2, figsize=(8, 4))species_u = penguins[&quot;species&quot;].unique()# plot 0 : matplotlib + seabornfor i, s in enumerate(species_u): # matplotlib 산점도 axes[0].scatter(penguins[&quot;bill_length_mm&quot;].loc[penguins[&quot;species&quot;]==s], penguins[&quot;bill_depth_mm&quot;].loc[penguins[&quot;species&quot;]==s], c=f&quot;C{i}&quot;, label=s, alpha=0.3 ) # seaborn 추세선 sns.regplot(&quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;, data=penguins.loc[penguins[&quot;species&quot;]==s], scatter=False, ax=axes[0]) axes[0].legend(species_u, title=&quot;species&quot;)axes[0].set_xlabel(&quot;Bill Length (mm)&quot;)axes[0].set_ylabel(&quot;Bill Depth (mm)&quot;)# plot 1 : seaborn + matplotlib# seaborn 산점도sns.scatterplot(&quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;, hue=&quot;species&quot;, data=penguins, alpha=0.3, ax=axes[1])axes[1].set_xlabel(&quot;Bill Length (mm)&quot;)axes[1].set_ylabel(&quot;Bill Depth (mm)&quot;)for i, s in enumerate(species_u): # matplotlib 중심점 axes[1].scatter(penguins[&quot;bill_length_mm&quot;].loc[penguins[&quot;species&quot;]==s].mean(), penguins[&quot;bill_depth_mm&quot;].loc[penguins[&quot;species&quot;]==s].mean(), c=f&quot;C{i}&quot;, alpha=1, marker=&quot;x&quot;, s=100 )fig.tight_layout() 1.6. seaborn + seaborn + matplotlib 안 될 이유가 없습니다. seaborn scatterplot + seaborn kdeplot + matplotlib text입니다. 1234567891011121314151617181920fig, ax = plt.subplots(figsize=(6,5))# plot 0: scatter plotsns.scatterplot(&quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;, color=&quot;k&quot;, data=penguins, alpha=0.3, ax=ax, legend=False)# plot 1: kde plotsns.kdeplot(&quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;, hue=&quot;species&quot;, data=penguins, alpha=0.5, ax=ax, legend=False)# text:species_u = penguins[&quot;species&quot;].unique()for i, s in enumerate(species_u): ax.text(penguins[&quot;bill_length_mm&quot;].loc[penguins[&quot;species&quot;]==s].mean(), penguins[&quot;bill_depth_mm&quot;].loc[penguins[&quot;species&quot;]==s].mean(), s = s, fontdict={&quot;fontsize&quot;:14, &quot;fontweight&quot;:&quot;bold&quot;,&quot;color&quot;:&quot;k&quot;} )ax.set_xlabel(&quot;Bill Length (mm)&quot;)ax.set_ylabel(&quot;Bill Depth (mm)&quot;)fig.tight_layout() 1.7. 결론 seaborn을 matplotlib과 마음껏 섞어쓰세요 단, axes를 반환하는 명령어에 한해서 말입니다. 이런 명령어를 axes-level function 이라고 합니다. 출저: https://jehyunlee.github.io/2020/09/30/Python-DS-34-seaborn_matplotlib/","link":"/2020/11/06/Seaborn_with_Matplotlib_1/"},{"title":"Seaborn with Matplotlib (3)","text":"3. seaborn figure-level function seaborn의 핵심기능, 강력한 명령입니다. 4부 중 세 번째 시간입니다. matplotlib으로는 매우 수고스러울 일을 줄여줍니다. 그러나 손대기 어렵기도 합니다. 이유와 해결방법을 알아봅시다. seaborn API seaborn tutorial seaborn with matplotlib (1) 지난 글에서 matplotlib과 친한 함수를 알아봤습니다. 이런 axex 반환 함수를 axes-level 함수, 반대로 그림 전체를 반환하는 함수를 figure-level 함수라고 합니다. 아래 노란 부분이 figure-level 함수입니다. 반환 형식return type이 왜 이렇게 깔끔하지 않은지는 뒤에 보겠습니다. figure-level 함수는 복잡한 그림을 한 번에 편하게 그려줍니다. 3.1. figure-level 편리함 맛보기: FacetGrid() seaborn에 내장된 penguins dataset에는 이런 데이터가 있습니다. bill_length_mm : 부리 길이 bill_depth_mm : 부리 위아래 두께 species : 펭귄 종 sex : 성별 island : 서식지 이 데이터를 산점도로 한번에 나타내고자 합니다. X축 : bill_length_mm Y축 : bill_depth_mm 색상 : species X방향 axes : island Y방향 axes : sex matplotlib 코드는 이렇습니다. 12345678910111213141516171819202122232425262728293031fig, axes = plt.subplots(nrows=2, ncols=3, figsize=(12, 8), sharex=True, sharey=True)# 인자별 데이터 종 수 세기sex = penguins[&quot;sex&quot;].dropna().unique()island = penguins[&quot;island&quot;].dropna().unique()species = penguins[&quot;species&quot;].dropna().unique()# X방향 axes: sexfor i in range(len(sex)): # Y방향 axes: island for j in range(len(island)): # 색상 : species for k in range(len(species)): try: axes[i][j].scatter(penguins.loc[penguins[&quot;sex&quot;] == sex[i]].loc[penguins[&quot;island&quot;] == island[j]].loc[penguins[&quot;species&quot;] == species[k]][&quot;bill_length_mm&quot;], penguins.loc[penguins[&quot;sex&quot;] == sex[i]].loc[penguins[&quot;island&quot;] == island[j]].loc[penguins[&quot;species&quot;] == species[k]][&quot;bill_depth_mm&quot;]) axes[i][j].set_title(f&quot;sex = {sex[i]} | island = {island[j]}&quot;) except: # 결측치 예외처리 pass # 맨 아래줄에만 xlabel 추가 axes[len(sex)-1, j].set_xlabel(&quot;bill_length_mm&quot;) # 맨 왼쪽에만 ylabel 추가 axes[i, 0].set_ylabel(&quot;bill_depth_mm&quot;)# 그래프 우측에 범례 표시fig.legend(species, title=&quot;species&quot;, bbox_to_anchor=(0.95, 0.5))# 그래프 간격 조정fig.tight_layout(rect=[0,0,0.85,1]) 따로 꾸민 것도 없는데 매우 번잡합니다. 인자별로 몇가지인지를 알아내야 합니다. 결측치 처리가 필요합니다. 안하면 에러납니다. 색상별로 따로 그려야 합니다. 그런데 seaborn을 사용하면 세 줄 만에 끝납니다. 123g = sns.FacetGrid(penguins, row=&quot;sex&quot;, col=&quot;island&quot;, hue=&quot;species&quot;)g.map(sns.scatterplot, &quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;)g.add_legend() FacetGrid()로 만든 공간을 .map()으로 채웁니다. 데이터셋 이름, 변수 이름, 그리는 방식 외에 다른 내용이 없습니다. 인자가 여럿인 관계를 보기에 아주 좋습니다. 밀도 함수density plot로 바꾸는 것도 간단합니다. 위 코드에서 sns.scatterplot만 sns.kdeplot으로 넣으면 됩니다. 123g = sns.FacetGrid(penguins, row=&quot;sex&quot;, col=&quot;island&quot;, hue=&quot;species&quot;)g.map(sns.kdeplot, &quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;)g.add_legend() figure-level 함수는 복잡한 그림을 간단히 그릴 때 매우 강력합니다. 이 그림들을 matplotlib으로 그리려면 얼마나 막막할까요. 3.2. figure-level 꾸미기: FacetGrid()seaborn.FacetGrid seaborn.kdeplot seaborn.regplot 이번엔 figure-level 그림을 꾸며 보겠습니다. kdeplot위에 추세선을 겹쳐 그립니다. 추세선이 중간에 안끊기면 좋겠습니다. 신뢰구간은 80% 수준으로 그리고 싶습니다. xlabel을 “Bill Length (mm)”로 바꾸고 ylabel을 “Bill Depth (mm)”로 바꿉니다. 공식 홈페이지의 설명에 힘입어 해냈습니다. 123456g = sns.FacetGrid(penguins, row=&quot;sex&quot;, col=&quot;island&quot;, hue=&quot;species&quot;)g.map(sns.kdeplot, &quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;, alpha=0.3)g.map(sns.regplot, &quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;, truncate=False, ci=80, scatter=False)g.set_axis_labels(&quot;Bill Length (mm)&quot;, &quot;Bill Depth (mm)&quot;)g.add_legend() 한 단계 더 꾸며보도록 합시다. xlabel, ylabel 글자를 키우고 싶습니다. 추세선의 신뢰구간 80%를 적어두고 싶습니다. axes마다 붙어 있는 title을 정리하고 싶습니다. 첫 단계에서 막혔습니다 xlabel, ylabel을 수정할 때 set_axis_labels()를 사용했습니다. 공식 홈페이지의 FacetGrid()부분 가이드를 따른 것입니다. 그런데 set_axis_labels()에 대한 설명이 더 이상 없습니다. 혹시나, matplotlib 명령어를 넣어봅니다. fontdict=를 적용합니다 1234567g = sns.FacetGrid(penguins, row=&quot;sex&quot;, col=&quot;island&quot;, hue=&quot;species&quot;)g.map(sns.kdeplot, &quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;, alpha=0.3)g.map(sns.regplot, &quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;, truncate=False, ci=80, scatter=False)g.set_axis_labels(&quot;Bill Length (mm)&quot;, &quot;Bill Depth (mm)&quot;, fontdict={&quot;fontsize&quot;:&quot;large&quot;, &quot;color&quot;:&quot;gray&quot;, &quot;fontweight&quot;:&quot;bold&quot;})g.add_legend() figure-level 그림의 세부 설정은 도움말 찾기도 어렵습니다. 매뉴얼에 없는 내용을 상상해서 넣어야 합니다. 아직은 공식 홈페이지가 충만하지 않습니다. 소스코드를 뜯어봐서 기능을 확인하거나 matplotlib 명령어를 숙지하고 대응시켜 시도해야 합니다. 3.3. figure-level의 장단점 공식 튜토리얼에 정리된 장단점은 이렇습니다 하나씩 짚어보겠습니다. (1) 데이터 변수에 따른 축공간 생성 matplotlib에서 변수 갯수를 세어야 했던 것에 비해서 편리합니다. seaborn에 구현된 그림을 제어하는 인자 수가 확실히 적습니다. 번거롭더라도 axes에 직접 접근해서 matplotlib 명령을 쓰는 게 낫습니다. (2) 그림 밖 범례 생성 그림 밖에 붙는 것은 다행입니다. 그러나 통제가 안되어 심각한 갈증을 유발합니다. (3) figure-level 수정 &amp; (4) figure size를 조정하는 인자가 다름 장점보다 단점이 크다고 생각됩니다. 더 쉬운 명령어를 제공한다고 해도 결국은 또 다른 문법입니다. matplotlib 명령어만 해도 정신이 없는데 말이죠. 지금까지의 경험으로 이런 결론이 나옵니다. “figure-level의 가성비는 그리자마자, 손을 더 대기 전이 가장 높다.” 새로운 명령어는 새로운 혼돈입니다. 시각화만 붙잡고 있을 게 아니라 통계분석, 머신러닝도 해야 하거든요. 3.4. figure-level그림이 손대기 어려운 이유github: seaborn source code seaborn 코드를 뜯어보면 클래스 구조는 이렇습니다. multi-plot grids는 Grid 클래스를 상속받는 가족입니다. FacetGrid(), PairGrid(), ClusterGrid 입니다. JointGrid()는 Grid를 상속받지 않습니다. Grid로 만든 공간에 목적에 맞는 그림을 채웁니다. relplot(), displot(), catplot(), lmplot()은 1x1 FacetGrid()로 출력됩니다. 그리고 Grid 클래스는 **figure**의 wrapper입니다. 정확히는 matplotlib.pyplot.subplots()의 wrapper입니다. 따라서 figure, axes에 적용되는 matplotlib 명령이 안통합니다. 그래서 set_axis_labels같은 자체 명령어를 탑재하고 있습니다. 하지만 보셨다시피 도움말이 충분치 않습니다. 3.5. figure-level 그림을 꾸미는 방법Doctor! The heart’s stopped! 한마디로, seaborn 제공 함수는 한계가 큽니다. 기능 자체도 많이 빠져있고 있는 기능도 문서화가 덜 됐습니다. 이걸 믿고 쓰긴 어렵습니다. 하지만 대안이 있습니다. seaborn 그림을 matplotlib 그림으로 간주합니다. figure-level 객체 안으로 한 걸음 들어갑니다. 그리고 figure와 axes를 직접 건드립니다. 개흉 심장마사지를 상상하시면 됩니다. 가슴을 열고 직접 심장을 마사지하는 겁니다. 그러면, 풀지 못했던 난제도 이렇게 풀립니다. 1234567891011121314151617181920212223242526272829g = sns.FacetGrid(penguins, row=&quot;sex&quot;, col=&quot;island&quot;, hue=&quot;species&quot;, margin_titles=True, despine=False)g.map(sns.kdeplot, &quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;, alpha=0.3)g.map(sns.regplot, &quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;, truncate=False, ci=80, scatter=False)g.add_legend()# xlabel, ylabel 수정g.set_axis_labels(&quot;Bill Length (mm)&quot;, &quot;Bill Depth (mm)&quot;, fontdict={&quot;fontsize&quot;:&quot;large&quot;, &quot;color&quot;:&quot;gray&quot;, &quot;fontweight&quot;:&quot;bold&quot;})# axes 직접 접근, 1차원 행렬로 표현axs = g.axes.ravel()for i, ax in enumerate(axs): # 열 title 수정 if i &lt; 3: ax.set_title(ax.get_title(), fontdict={&quot;fontsize&quot;:&quot;x-large&quot;, &quot;color&quot;:&quot;k&quot;}, pad=12) # 행 title 수정 if i%3 == 2: sex = &quot;Male&quot; if i == 2 else &quot;Female&quot; ax.texts.clear() text = ax.annotate(f&quot;sex = {sex}&quot;, xy=(1.02, .5), xycoords=&quot;axes fraction&quot;, rotation=270, ha=&quot;left&quot;, va=&quot;center&quot;, fontsize=&quot;x-large&quot;, color=&quot;k&quot;)# suptitle 추가g.fig.suptitle(&quot;Penguins dataset summary (ci = 80%) &quot;, fontsize=&quot;xx-large&quot;, fontweight=&quot;bold&quot;, color=&quot;indigo&quot;)# 전반적 크기 조정 g.fig.tight_layout(rect=[0,0,0.88,0.97]) 외웁시다. figure-level 함수는 matplotlib과 못 섞는다. figure-level 함수는 figure와 axes를 한번 더 감싸고 있다. figure-level 함수를 수정하려면 후벼 파는 과정이 필요하다. 출저: https://jehyunlee.github.io/2020/10/06/Python-DS-36-seaborn_matplotlib3/","link":"/2020/11/06/Seaborn_with_Matplotlib_3/"},{"title":"Seaborn with Matplotlib (4)","text":"4. seaborn figure-level 다듬기 seaborn + matplotlib 마지막 시간입니다. figure-level 그림을 그리고 다듬어 봅니다. 자체적으로 지원하는 명령어를 사용해보고, 개흉 심장마사지 방법을 알아보겠습니다. seaborn API seaborn tutorial 4.1. figure-level으로 편리하게 그리기: pairplot()wikipedia: Exploratory data analysis wikipedia: Anscombe’s quartet autodesk: datasaurus seaborn.pairplot EDA에서 피할 수 없는 과정이 상관도입니다. 두 변수 사이의 관계를 그려 관계를 파악합니다. 대개 산점도scatter plot나 밀도 함수density plot를 쓰고, 추세선regression을 덧붙이는 경우도 있습니다. 데이터 분포는 통계값으로만 확인하면 안됩니다. 평균과 표준편차는 같은데 분포는 다른 경우가 많습니다. 반드시 분포를 그려 봐야 합니다. Anscombe’s quartet이 아주 좋은 예시입니다. N개의 인자 사이에는 \\(N(N−1)/2\\)가지 관계가 있습니다. seaborn의 pairplot()은 여러 인자 사이의 수많은 상관도를 쉽게 그려줍니다. 붓꽃iris 데이터셋으로 상관도를 그려봅니다. 꽃받침sepal과 꽃잎petal, 길이length와 폭width 네 가지 인자로부터 여섯 가지의 상관도, 네 가지의 히스토그램이 나옵니다. 코드 한 줄로 그려봅시다. 123import seaborn as snsiris = sns.load_dataset(&quot;iris&quot;) 종species별 분포를 그려봅니다. 1g = sns.pairplot(iris, hue=&quot;species&quot;) hue=라는 인자 하나만 추가했을 뿐입니다. 그림이 갑자기 예뻐졌습니다. 히스토그램도 밀도함수로 바뀌어서 훨씬 보기 좋습니다. 여기에 다른 그림을 겹쳐보겠습니다. 대각선 위 : 2차원 밀도함수 + 추세선 대각선 아래 : 2차원 밀도함수 + 산포도 seaborn figure-level 기능만으로 가능합니다. .map_lower()와 .map_upper를 사용합니다. 123g = sns.pairplot(iris, hue=&quot;species&quot;, kind=&quot;kde&quot;, plot_kws={&quot;alpha&quot;:0.3})g.map_lower(sns.scatterplot)g.map_upper(sns.regplot, scatter=False, truncate=False, ci=False) map_lower()와 map_upper()는 대각선의 위와 아래에 그림을 덧씌우는map 함수입니다. 앞서 완성한 pairplot에 새로운 그림을 덧붙입니다. 인자로는 함수 이름과 이 함수의 옵션들을 연달아 넣어 줍니다. 함수에 맞는 인자를 넣어줘야 합니다. 4.2. figure-level 그림 뼈대부터 세우기: PairGrid()seaborn.PairGrid pairplot을 단계별로 그리는 방법입니다. 코드 양은 pairplot()한 줄보다 늘어납니다. 그러나 자유도가 늘어납니다. .pairplot() 으로는 위 아래를 완전히 다르게 할 수 없습니다. 대각선의 아래엔 산점도와 추세선을 그리고 대각선 위에는 밀도함수만 그려보겠습니다. 123456789101112131415# 틀 만들기g = sns.PairGrid(iris, hue=&quot;species&quot;, diag_sharey=False)# diagonalg.map_diag(sns.kdeplot, fill=True)# lowerg.map_lower(plt.scatter, s=30, edgecolor=&quot;w&quot;)g.map_lower(sns.regplot, scatter=False, truncate=False, ci=False)# upperg.map_upper(sns.kdeplot, alpha=0.3)# legendg.add_legend() .pairplot()과 같은 형식의 그림이 나왔습니다. 내 의도를 더 잘 반영할 수 있게 되었습니다. 8번째 줄에는 plt.scatter가 들어가 있습니다. .pairplot()도 마찬가지지만 .map()에는 seaborn대신 matplotlib - 함수를 사용할 수 있습니다. 중복되는 오른쪽 윗부분을 생략할 수 있습니다. corner=True를 넣어줍니다. 123456789101112g = sns.PairGrid(iris, hue=&quot;species&quot;, diag_sharey=False, corner=True)# diagonalg.map_diag(sns.kdeplot, fill=True)# lowerg.map_lower(plt.scatter, s=30, edgecolor=&quot;w&quot;)g.map_lower(sns.regplot, scatter=False, truncate=False, ci=False)g.map_lower(sns.kdeplot, alpha=0.3)# legendg.add_legend() 이제 작은 수정을 해봅니다. 대각선에 사각 테두리 치기 범례를 그림 안으로 가져오기 가슴을 열고 심장마사지를 할 시간입니다. 4.3. figure-level 그림 객체 접근seaborn.FacetGrid matplotlib.figure.Figure matplotlib.axes.Axes matplolib 그림은 figure와 axes로 나뉩니다. seaborn 그림도 결국 matplotlib 그림입니다. seaborn의 figure와 axes에 접근하면 됩니다. 4.3.1. axes: .axes 이전 글에서 axes를 이용해 jointplot을 재현했습니다. axes 객체는 .axes를 이용해 접근 가능합니다. 1g.axes 확인 결과 AxesSubplot의 array입니다. 4.3.1.1. 특정 axes 윤곽선 그리기Seaborn with Matplotlib (2) Spines &amp; Grids 정체를 알았으니 axes[i][j]로 접근할 수 있습니다. g.axes[i][j]의 spine을 보이게 합니다. 12345678910111213141516g = sns.PairGrid(iris, hue=&quot;species&quot;, diag_sharey=False, corner=True)# diagonalg.map_diag(sns.kdeplot, fill=True)for i in range(4): g.axes[i][i].spines[&quot;left&quot;].set_visible(True) g.axes[i][i].spines[&quot;top&quot;].set_visible(True) g.axes[i][i].spines[&quot;right&quot;].set_visible(True) # lowerg.map_lower(plt.scatter, s=30, edgecolor=&quot;w&quot;)g.map_lower(sns.regplot, scatter=False, truncate=False, ci=False)g.map_lower(sns.kdeplot, alpha=0.3)# legendg.add_legend() 4.3.1.2. 범례 조정seaborn axisgrid.py 소스코드 matplotlib.axes.Axes.get_legend_handles_labels matplotlib.axes.Axes.legend legend 정보를 가져와서 legend로 삽입합니다. 대개 legend에 필요한 handles와 labels는 .get_legend_handles_labels()로 가져옵니다. 하지만 seaborn figure-level 그림엔 이 명령이 통하지 않습니다. private처럼 보이는 ._legend_data를 사용합니다. 공식 문서에 없습니다. 소스 코드를 뒤적여야 합니다. ._legend_data 정체를 확인합니다. 범례가 dict 형식으로 들어 있습니다. 1g._legend_data 아래 코드를 추가하여 범례를 이동합니다. 12345678handles = g._legend_data.values()labels = g._legend_data.keys()# axes[1][0] 기준으로 오른쪽 멀리 범례 삽입g.axes[1][0].legend(handles=handles, labels=labels, bbox_to_anchor=(3.45, 1), fontsize=&quot;large&quot;, frameon=False ) 이런 방식으로 특정 axes만 제어할 수 있습니다. 원하는 그림, 글자을 넣을 수 있고 특정 데이터의 색상을 변경할 수 있습니다. 4.3.2. figure: .fig 개별 공간은 axes로 제어하지만 여러 axes가 연관된 공간은 figure로 제어합니다. figure 객체는 .fig를 이용해 접근 가능합니다 1type(g.fig) type()으로 감싸주지 않으면 그림이 통으로 출력됩니다. 4.3.2.1. ylabel alignmentmatplolib.figure.Figure #align_ylabels matplotlib Align y-labels 위 그림에서 ylabel 줄이 잘 맞지 않습니다. 맨 왼쪽 아래 axes[3][0]의 label이 비죽 나왔네요. 다른 ylabel을 움직여서 열을 맞춰 봅시다. 위 그림 코드의 맨 마지막 줄에 한 줄만 추가합니다 1g.fig.align_ylabels(g.axes[:,0]) 4.3.2.2. 범례 조정matplolib.figure.Figure #legend 범례는 figure 기준으로도 삽입 가능합니다. 아래 코드는 위의 axes[1][0].legend()와 동일합니다. 전체적인 그림의 위치를 잡을 수 있어 더 좋습니다. 123g.fig.legend(handles=handles, labels=labels, bbox_to_anchor=(0.75, 0.75), fontsize=&quot;large&quot;) 4.3.2.3. suptitlematplolib.figure.Figure #suptitle 그림 전체에 제목을 붙일 수 있습니다. 1234g.fig.suptitle(&quot;iris dataset&quot;, y=1.01, weight=&quot;bold&quot;, fontsize=&quot;x-large&quot; )g.fig.tight_layout() 4.3.2.4. facecolor, edgecolormatplolib.figure.Figure #set_facecolor 그림 바탕색을 칠합니다. 1g.fig.set_facecolor(&quot;whitesmoke&quot;) 4.3.3. 최종 x, ylabel까지 정리하면 이렇습니다. 123456789101112131415161718192021222324252627282930313233343536373839g = sns.PairGrid(iris, hue=&quot;species&quot;, diag_sharey=False, corner=True)# diagonalg.map_diag(sns.kdeplot, fill=True)for i in range(4): g.axes[i][i].spines[&quot;left&quot;].set_visible(True) g.axes[i][i].spines[&quot;top&quot;].set_visible(True) g.axes[i][i].spines[&quot;right&quot;].set_visible(True) # lowerg.map_lower(plt.scatter, s=30, edgecolor=&quot;w&quot;)g.map_lower(sns.regplot, scatter=False, truncate=False, ci=False)g.map_lower(sns.kdeplot, alpha=0.3)# legendhandles = g._legend_data.values()labels = g._legend_data.keys()g.fig.legend(handles=handles, labels=labels, bbox_to_anchor=(0.75, 0.75), fontsize=&quot;large&quot;)# x, y labelslabels = [&quot;Sepal Length&quot;, &quot;Sepal Width&quot;, &quot;Petal Length&quot;, &quot;Petal Width&quot;]font_labels = {&quot;fontsize&quot;:&quot;large&quot;, &quot;color&quot;:&quot;gray&quot;, &quot;fontweight&quot;:&quot;bold&quot;}for i in range(4): g.axes[3, i].set_xlabel(labels[i], fontdict=font_labels) g.axes[i, 0].set_ylabel(labels[i], fontdict=font_labels)# ylabel alignmentg.fig.align_ylabels(g.axes[:,0])# suptitleg.fig.suptitle(&quot;iris dataset&quot;, y=1.01, weight=&quot;bold&quot;, fontsize=&quot;x-large&quot; )g.fig.tight_layout()# facecolorg.fig.set_facecolor(&quot;whitesmoke&quot;) 5. 결론 네 편의 글에 걸쳐 matplotlib + seaborn 연계기를 정리했습니다. 개별적인 코드와 기술보다는 본질에 집중합시다. figure와 axes를 통하면 웬만한건 다 된다는 겁니다. 0.11에서 seaborn의 공식문서가 대폭 정리됐습니다. 하지만 아직 부족한 점이 많습니다. 특히 많은 경우 matplotlib에 숙달되었다고 전제합니다. 일단 matplotlib부터 제대로 익혀봅시다. 출저: https://jehyunlee.github.io/2020/10/10/Python-DS-37-seaborn_matplotlib4/","link":"/2020/11/06/Seaborn_with_Matplotlib_4/"},{"title":"Seaborn with Matplotlib (2)","text":"2. seaborn + matplotlib을 이용한 jointplot 보완 seaborn을 matplotlib과 섞어쓰는 방법입니다. 4부 중 두 번째 시간입니다. seaborn jointplot의 단점을 보완합니다. 2.1. seaborn jointplotseaborn API seaborn의 jointplot은 매력적인 기능입니다. 두 변수 각각의 분포와 2차원 분포를 함께 보여줍니다. 각각의 분포는 histogram과 kdeplot으로 표현할 수 있고 2차원 분포는 scatterplot, regression, kdeplot, hexbin등으로 표현할 수 있습니다. 만약 matplotlib에서 일일이 만들어야 한다면 눈물이 앞을 가릴 일입니다. seaborn에서는 단 한 줄로 이런 그림들이 탄생합니다. 2.2. multiple jointplot 그러나 seaborn 만으로는 여러 jointplot이 합쳐진 그림을 표현할 수 없습니다. y축을 공유시키는 것 만으로도 훨씬 기능이 강력해질텐데요. 현실적으로 가장 빠른 방법은 파워포인트입니다. 같은 y축 범위로 그림을 여러 개 그린 후 붙이면 됩니다. 그러나 수작업이 동반되고, 오류 가능성이 커집니다. seaborn과 matplotlib의 힘을 합해서 그려봅시다. 2.3. matplotlib + seaborn 지난 글에서 seaborn과 matplotlib이 섞일 수 있음을 보였습니다. matplotlib으로 틀을 만들고 여기에 seaborn을 삽입합니다. 12345import matplotlib.pyplot as pltimport seaborn as snspenguins = sns.load_dataset(&quot;penguins&quot;) # 펭귄 데이터셋으로 시작합니다.penguins.head() 가로축에 두 개의 데이터 : bill_length_mm, flipper_length_mm, 세로축에 한 개의 데이터 : bill_depth_mm를 놓아보겠습니다. 2.3.1. 축공간 배열 : gridspecmatplotlib.pyplot.subplots matplotlib.gridspec.GridSpec 저는 matplotlib을 객체지향 방식으로 사용할 때 이렇게 합니다. fig, ax = plt.subplots() 명령으로 figure와 axes를 만드는데 가로세로 여러 axes를 만들 때는 ncols, nrows 인자를 사용합니다. 그러나 이렇게 하면 모든 축공간의 크기가 같아집니다. jointplot은 축공간의 크기가 일정하지 않습니다. gridspec을 이용해서 비대칭 축공간을 만듭니다. 12345678910111213fig = plt.figure(figsize=(12,7))widths = [4, 4, 1]heights = [1, 4]### 1. gridspec preparationspec = fig.add_gridspec(ncols=3, nrows=2, width_ratios=widths, height_ratios=heights)### 2. setting axesaxs = {}for i in range(len(heights)*len(widths)): axs[i] = fig.add_subplot(spec[i//len(widths), i%len(widths)]) axs[i].text(0.5, 0.5, f&quot;axs[{i}]&quot;, fontdict={&quot;horizontalalignment&quot;:&quot;center&quot;, &quot;color&quot;:&quot;gray&quot;}) 축공간은 원래 2차원 배열입니다. 하지만 이를 별로 좋아하지 않아서, dictionary를 사용해 1차원으로 취급합니다. 개인적인 취향입니다. 꼭 따르지 않아도 좋습니다. 2.3.2. 첫 번째 jointplot : scatterplot + kdeplotseaborn.scatterplot seaborn.kdeplot 좌측 하단에 첫 번째 2차원 분포도를 그립니다. x축 변수는 bill_length_nm, y축 변수는 bill_depth_mm로 지정합니다. seaborn 명령의 ax= 인자를 사용해 축공간을 지정합니다. 1234567891011121314151617181920fig = plt.figure(figsize=(12,7))widths = [4, 4, 1]heights = [1, 4]# 1. gridspec preparationspec = fig.add_gridspec(ncols=3, nrows=2, width_ratios=widths, height_ratios=heights)# 2. setting axesaxs = {}for i in range(len(heights)*len(widths)): axs[i] = fig.add_subplot(spec[i//len(widths), i%len(widths)])# 3. bill_length_mm vs bill_depth_mm# 3.1. kdeplotsns.kdeplot(&quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;, data=penguins, hue=&quot;species&quot;, alpha=0.3, ax=axs[3])# 3.2. scatterplotsns.scatterplot(&quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;, data=penguins, hue=&quot;species&quot;, ax=axs[3])fig.tight_layout() 2.3.3. 첫 번째 jointplot : 1차원 kdeplot 첫 번째 jointplot의 상단과 우측에 1차원 분포도를 그립니다. 두 가지를 주의해야 합니다. 중심이 되는 jointplot과 가로세로 범위를 일치시켜야 합니다. 1차원 분포도의 눈금과 수치는 필요없으니 제거합니다. 123456789101112131415161718192021222324252627282930313233343536373839fig = plt.figure(figsize=(12,7))widths = [4, 4, 1]heights = [1, 4]### 1. gridspec preparationspec = fig.add_gridspec(ncols=3, nrows=2, width_ratios=widths, height_ratios=heights)### 2. setting axesaxs = {}for i in range(len(heights)*len(widths)): axs[i] = fig.add_subplot(spec[i//len(widths), i%len(widths)])### 3. bill_length_mm vs bill_depth_mm# 3.1. kdeplotsns.kdeplot(&quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;, data=penguins, hue=&quot;species&quot;, alpha=0.3, ax=axs[3])# 3.2. scatterplotsns.scatterplot(&quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;, data=penguins, hue=&quot;species&quot;, ax=axs[3])# 3.3. histogram (bill_length_mm)sns.kdeplot(&quot;bill_length_mm&quot;, data=penguins, hue=&quot;species&quot;, ax=axs[0], legend=False)axs[0].set_xlim(axs[3].get_xlim())axs[0].set_xlabel('')axs[0].set_xticklabels([])axs[0].spines[&quot;left&quot;].set_visible(False)axs[0].spines[&quot;top&quot;].set_visible(False)axs[0].spines[&quot;right&quot;].set_visible(False)# 3.3. histogram (bill_depth_mm)sns.kdeplot(y=&quot;bill_depth_mm&quot;, data=penguins, hue=&quot;species&quot;, ax=axs[5], legend=False)axs[5].set_ylim(axs[3].get_ylim())axs[5].set_ylabel('')axs[5].set_yticklabels([])axs[5].spines[&quot;bottom&quot;].set_visible(False)axs[5].spines[&quot;top&quot;].set_visible(False)axs[5].spines[&quot;right&quot;].set_visible(False)fig.tight_layout() 2.3.4. 두 번째 jointplot 같은 요령으로 두 번째 분포도 도시합니다. 첫 번째 jointplot에서 x 변수만 바꿔주면 됩니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455fig = plt.figure(figsize=(12,7))widths = [4, 4, 1]heights = [1, 4]### 1. gridspec preparationspec = fig.add_gridspec(ncols=3, nrows=2, width_ratios=widths, height_ratios=heights)### 2. setting axesaxs = {}for i in range(len(heights)*len(widths)): axs[i] = fig.add_subplot(spec[i//len(widths), i%len(widths)])### 3. bill_length_mm vs bill_depth_mm# 3.1. kdeplotsns.kdeplot(&quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;, data=penguins, hue=&quot;species&quot;, alpha=0.3, ax=axs[3])# 3.2. scatterplotsns.scatterplot(&quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;, data=penguins, hue=&quot;species&quot;, ax=axs[3])# 3.3. histogram (bill_length_mm)sns.kdeplot(&quot;bill_length_mm&quot;, data=penguins, hue=&quot;species&quot;, ax=axs[0], legend=False)axs[0].set_xlim(axs[3].get_xlim())axs[0].set_xlabel('')axs[0].set_xticklabels([])axs[0].spines[&quot;left&quot;].set_visible(False)axs[0].spines[&quot;top&quot;].set_visible(False)axs[0].spines[&quot;right&quot;].set_visible(False)# 3.3. histogram (bill_depth_mm)sns.kdeplot(y=&quot;bill_depth_mm&quot;, data=penguins, hue=&quot;species&quot;, ax=axs[5], legend=False)axs[5].set_ylim(axs[3].get_ylim())axs[5].set_ylabel('')axs[5].set_yticklabels([])axs[5].spines[&quot;bottom&quot;].set_visible(False)axs[5].spines[&quot;top&quot;].set_visible(False)axs[5].spines[&quot;right&quot;].set_visible(False)### 4. flipper_length_mm vs bill_depth_mm# 3.1. kdeplotsns.kdeplot(&quot;flipper_length_mm&quot;, &quot;bill_depth_mm&quot;, data=penguins, hue=&quot;species&quot;, alpha=0.3, ax=axs[4])# 3.2. scatterplotsns.scatterplot(&quot;flipper_length_mm&quot;, &quot;bill_depth_mm&quot;, data=penguins, hue=&quot;species&quot;, ax=axs[4])# 3.3. histogram (bill_length_mm)sns.kdeplot(&quot;flipper_length_mm&quot;, data=penguins, hue=&quot;species&quot;, ax=axs[1], legend=False)axs[1].set_xlim(axs[4].get_xlim())axs[1].set_xlabel('')axs[1].set_xticklabels([])axs[1].spines[&quot;left&quot;].set_visible(False)axs[1].spines[&quot;top&quot;].set_visible(False)axs[1].spines[&quot;right&quot;].set_visible(False)fig.tight_layout() 2.3.5. 부대효과 조정 : spines, grids, 간격 데이터는 모두 올라갔으니 부대 효과를 조정합니다. 불필요한 요소(ex. spines)는 제거하고, 애매한 요소(ex. 위치)는 grid로 명확히 합니다 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576fig = plt.figure(figsize=(12,7))widths = [4, 4, 1]heights = [1, 4]### 1. gridspec preparationspec = fig.add_gridspec(ncols=3, nrows=2, width_ratios=widths, height_ratios=heights, wspace=0.03, hspace=0.03) # setting spaces### 2. setting axesaxs = {}for i in range(len(heights)*len(widths)): axs[i] = fig.add_subplot(spec[i//len(widths), i%len(widths)])### 3. bill_length_mm vs bill_depth_mm# 3.1. kdeplotsns.kdeplot(&quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;, data=penguins, hue=&quot;species&quot;, alpha=0.3, ax=axs[3], zorder=1)# 3.2. scatterplotsns.scatterplot(&quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;, data=penguins, hue=&quot;species&quot;, ax=axs[3], zorder=2)# 3.3. histogram (bill_length_mm)sns.kdeplot(&quot;bill_length_mm&quot;, data=penguins, hue=&quot;species&quot;, ax=axs[0], legend=False, zorder=1)axs[0].set_xlim(axs[3].get_xlim())axs[0].set_xlabel('')axs[0].set_xticklabels([])axs[0].spines[&quot;left&quot;].set_visible(False)axs[0].spines[&quot;top&quot;].set_visible(False)axs[0].spines[&quot;right&quot;].set_visible(False)# 3.3. histogram (bill_depth_mm)sns.kdeplot(y=&quot;bill_depth_mm&quot;, data=penguins, hue=&quot;species&quot;, ax=axs[5], legend=False, zorder=1)axs[5].set_ylim(axs[3].get_ylim())axs[5].set_ylabel('')axs[5].set_yticklabels([])axs[5].spines[&quot;bottom&quot;].set_visible(False)axs[5].spines[&quot;top&quot;].set_visible(False)axs[5].spines[&quot;right&quot;].set_visible(False)### 4. flipper_length_mm vs bill_depth_mm# 4.1. kdeplotsns.kdeplot(&quot;flipper_length_mm&quot;, &quot;bill_depth_mm&quot;, data=penguins, hue=&quot;species&quot;, alpha=0.3, ax=axs[4], zorder=1)# 4.2. scatterplotsns.scatterplot(&quot;flipper_length_mm&quot;, &quot;bill_depth_mm&quot;, data=penguins, hue=&quot;species&quot;, ax=axs[4], zorder=2)# 4.3. histogram (flipper_length_mm)sns.kdeplot(&quot;flipper_length_mm&quot;, data=penguins, hue=&quot;species&quot;, ax=axs[1], legend=False, zorder=1)axs[1].set_xlim(axs[4].get_xlim())axs[1].set_xlabel('')axs[1].set_xticklabels([])axs[1].spines[&quot;left&quot;].set_visible(False)axs[1].spines[&quot;top&quot;].set_visible(False)axs[1].spines[&quot;right&quot;].set_visible(False)### 5. unnecessary elements removal# 5.1. upper-right axesaxs[2].axis(&quot;off&quot;)# 5.2. margin kdeplot scale unificationhist_range_max = max(axs[0].get_ylim()[-1], axs[1].get_ylim()[-1], axs[5].get_xlim()[-1])for i in range(len(widths)-1): axs[i].set_ylim(0, hist_range_max)axs[5].set_xlim(0, hist_range_max)# 5.3. redundent labels and titles removalaxs[1].set_yticklabels([])axs[1].set_ylabel('')axs[4].set_yticklabels([])axs[4].set_ylabel('')# 5.4. gridsfor i in range(len(heights)*len(widths)): axs[i].grid(&quot;on&quot;, color=&quot;lightgray&quot;, zorder=0)fig.tight_layout() 1차원 분포의 스케일도 맞춰주었습니다. 그러나 꼭 필요한 작업인지는 의구심이 듭니다. ‘밀도’라는 정의에 맞게 넓이를 1로 만드는 과정이 포함되어 있는데, 이로 인해 x축 스케일이 크면 높이가 낮아지는 경향이 있기 때문입니다. 데이터의 범위에 집중하고 싶다면 스케일을 맞추지 않는 것이 나을지도 모릅니다. 2.3.6. 마무리 작업seaborn tutorial: controlling figure aesthetics 데이터를 표현하는 작업은 사실상 완료되었습니다. 폰트의 크기, 색상 등 가독성을 높입니다. 이 때도 seaborn의 set_style()과 set_context()를 사용하면 편리합니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788sns.set_style(&quot;white&quot;)sns.set_context(&quot;talk&quot;)fig = plt.figure(figsize=(14,8))widths = [4, 4, 1]heights = [1, 4]### 1. gridspec preparationspec = fig.add_gridspec(ncols=3, nrows=2, width_ratios=widths, height_ratios=heights, wspace=0.03, hspace=0.03) # setting spaces### 2. setting axesaxs = {}for i in range(len(heights)*len(widths)): axs[i] = fig.add_subplot(spec[i//len(widths), i%len(widths)])### 3. bill_length_mm vs bill_depth_mm# 3.1. kdeplotsns.kdeplot(&quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;, data=penguins, hue=&quot;species&quot;, alpha=0.3, ax=axs[3], zorder=1, legend=False)# 3.2. scatterplotsns.scatterplot(&quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;, data=penguins, hue=&quot;species&quot;, ax=axs[3], zorder=2, legend=False)# 3.3. histogram (bill_length_mm)sns.kdeplot(&quot;bill_length_mm&quot;, data=penguins, hue=&quot;species&quot;, ax=axs[0], legend=False, zorder=1, fill=True)axs[0].set_xlim(axs[3].get_xlim())axs[0].set_xlabel('')axs[0].set_xticklabels([])axs[0].spines[&quot;left&quot;].set_visible(False)axs[0].spines[&quot;top&quot;].set_visible(False)axs[0].spines[&quot;right&quot;].set_visible(False)# 3.3. histogram (bill_depth_mm)sns.kdeplot(y=&quot;bill_depth_mm&quot;, data=penguins, hue=&quot;species&quot;, ax=axs[5], legend=False, zorder=1, fill=True)axs[5].set_ylim(axs[3].get_ylim())axs[5].set_ylabel('')axs[5].set_yticklabels([])axs[5].spines[&quot;bottom&quot;].set_visible(False)axs[5].spines[&quot;top&quot;].set_visible(False)axs[5].spines[&quot;right&quot;].set_visible(False)### 4. flipper_length_mm vs bill_depth_mm# 4.1. kdeplotsns.kdeplot(&quot;flipper_length_mm&quot;, &quot;bill_depth_mm&quot;, data=penguins, hue=&quot;species&quot;, alpha=0.3, ax=axs[4], zorder=1)# 4.2. scatterplotsns.scatterplot(&quot;flipper_length_mm&quot;, &quot;bill_depth_mm&quot;, data=penguins, hue=&quot;species&quot;, ax=axs[4], zorder=2)# 4.3. histogram (flipper_length_mm)sns.kdeplot(&quot;flipper_length_mm&quot;, data=penguins, hue=&quot;species&quot;, ax=axs[1], legend=False, zorder=1, fill=True)axs[1].set_xlim(axs[4].get_xlim())axs[1].set_xlabel('')axs[1].set_xticklabels([])axs[1].spines[&quot;left&quot;].set_visible(False)axs[1].spines[&quot;top&quot;].set_visible(False)axs[1].spines[&quot;right&quot;].set_visible(False)### 5. unnecessary elements removal# 5.1. upper-right axesaxs[2].axis(&quot;off&quot;)# 5.2. margin kdeplot scale unificationhist_range_max = max(axs[0].get_ylim()[-1], axs[1].get_ylim()[-1], axs[5].get_xlim()[-1])for i in range(len(widths)-1): axs[i].set_ylim(0, hist_range_max)axs[5].set_xlim(0, hist_range_max)# 5.3. redundent labels and titles removalaxs[1].set_yticklabels([])axs[1].set_ylabel('')axs[4].set_yticklabels([])axs[4].set_ylabel('')# 5.4. gridsfor i in range(len(heights)*len(widths)): axs[i].grid(&quot;on&quot;, color=&quot;lightgray&quot;, zorder=0) # 5.5. labelsfont_label = {&quot;color&quot;:&quot;gray&quot;}axs[3].set_xlabel(&quot;Bill Legnth (mm)&quot;, fontdict=font_label, labelpad=12)axs[3].set_ylabel(&quot;Bill Depth (mm)&quot;, fontdict=font_label, labelpad=12)axs[4].set_xlabel(&quot;Flipper Legnth (mm)&quot;, fontdict=font_label, labelpad=12)axs[0].set_ylabel(&quot;Density&quot;, fontdict=font_label, labelpad=12)axs[5].set_xlabel(&quot;Density&quot;, fontdict=font_label, labelpad=12)fig.tight_layout() jointplot의 한계인 2중 jointplot이 구현되었습니다. 2.3.7. generalize : 함수로 만들기 하는 김에, 기능을 일반화합시다. 다중 jointplot 제작 기능을 함수로 만들고, x 변수의 수와 그림 크기, 1차원 분포 스케일 통일 등을 인자로 만듭니다 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163def jointplots(xs, y, data, hue=None, height=6, ratio=5, space=0.2, xlabels=None, ylabel=None, margin_norm=False): &quot;&quot;&quot; ------------------- Input Parameters ------------------- xs : (list or str) feature name(s) of data y : (str) feature name of data data : (pandas.DataFrame) hue : (str) semantic variable that is mapped to determine the color of plot elements. Semantic variable that is mapped to determine the color of plot elements. height : (float) size of the figure ratio : (float) ratio of the joint axes height to marginal axes height. space : (float) space between the joint and marginal axes xlabels : (list or str) xlabels ylabel : (str) ylabel margin_norm : (boolean) if True, kdeplots at marginal axes have same scale. &quot;&quot;&quot; ### 1. input check # input type assert isinstance(xs, list) or isinstance(xs, str) if isinstance(xs, list): assert all([isinstance(x, str) for x in xs]) else: xs = [xs] if xlabels != None: assert isinstance(xlabels, list) or isinstance(xlabels, str) if isinstance(xlabels, list): assert all([isinstance(xlabel, str) for xlabel in xlabels]) else: xlabels = [xlabels] if ylabel != None: assert isinstance(ylabel, str) if hue != None: assert isinstance(hue, str) # input data assert all([x in data.columns for x in xs]) assert y in data.columns if hue != None: assert hue in data.columns ### 2. figure h_margin = height / (ratio + 1) h_joint = height - h_margin if isinstance(xs, list): n_x = len(xs) else: n_x = 1 widths = [h_joint] * n_x + [h_margin] heights = [h_margin, h_joint] ncols = len(widths) nrows = len(heights) fig = plt.figure(figsize=(sum(widths), sum(heights))) ### 3. gridspec preparation spec = fig.add_gridspec(ncols=ncols, nrows=nrows, width_ratios = widths, height_ratios = heights, wspace=space, hspace=space ) ### 4. setting axes axs = {} for i in range(ncols * nrows): axs[i] = fig.add_subplot(spec[i//ncols, i%ncols]) ### 5. jointplots (scatterplot + kdeplot) for i, x in enumerate(xs, ncols): if i == ncols: legend=True else: legend=False sns.kdeplot(x=x, y=y, data=data, hue=hue, alpha=0.3, ax=axs[i], zorder=2, legend=False) sns.scatterplot(x=x, y=y, data=data, hue=hue, alpha=0.8, ax=axs[i], zorder=3, legend=legend) ### 6. kdeplots at marginal axes axs[ncols-1].axis(&quot;off&quot;) axes_mx = list(range(ncols-1)) axes_my = 2*ncols - 1 for i, x in zip(axes_mx, xs): sns.kdeplot(x=x, data=data, hue=hue, fill=True, ax=axs[i], zorder=2, legend=False) axs[i].set_xlim(axs[i+ncols].get_xlim()) axs[i].set_xlabel(&quot;&quot;) axs[i].set_xticklabels([]) axs[i].spines[&quot;left&quot;].set_visible(False) axs[i].spines[&quot;top&quot;].set_visible(False) axs[i].spines[&quot;right&quot;].set_visible(False) sns.kdeplot(y=y, data=data, hue=hue, fill=True, ax=axs[axes_my], zorder=2, legend=False) axs[axes_my].set_ylim(axs[ncols].get_ylim()) axs[axes_my].set_ylabel(&quot;&quot;) axs[axes_my].set_yticklabels([]) axs[axes_my].spines[&quot;bottom&quot;].set_visible(False) axs[axes_my].spines[&quot;top&quot;].set_visible(False) axs[axes_my].spines[&quot;right&quot;].set_visible(False) if margin_norm == True: hist_range_max = max([axs[m].get_ylim()[-1] for m in axes_mx] + [axs[axes_my].get_xlim()[-1]]) for i in axes_mx: axs[i].set_ylim(0, hist_range_max) axs[axes_my].set_xlim(0, hist_range_max) ### 7. unnecessary elements removal # 7.1. labels and ticklabels axes_j = list(range(ncols, 2*ncols-1)) for i in axes_j: if i != ncols: axs[i].set_ylabel(&quot;&quot;) axs[i].set_yticklabels([]) # 7.2. marginal axes for i in axes_mx: if i != 0: axs[i].set_ylabel(&quot;&quot;) axs[i].grid(&quot;on&quot;, color=&quot;lightgray&quot;, zorder=0) axs[i].set_yticklabels([]) yticks = axs[i].get_yticks() ylim = axs[i].get_ylim() for ytick in yticks: if 0 &lt; ytick &lt; ylim[-1]: axs[i].text(axs[i].get_xlim()[0], ytick, str(ytick), fontdict={&quot;verticalalignment&quot;:&quot;center&quot;}) axs[axes_my].grid(&quot;on&quot;, color=&quot;lightgray&quot;, zorder=0) axs[axes_my].set_xticklabels([]) axes_my_xticks = axs[axes_my].get_xticks() axes_my_xlim = axs[axes_my].get_xlim() for xtick in axes_my_xticks: if 0 &lt; xtick &lt; axes_my_xlim[-1]: axs[axes_my].text(xtick, axs[axes_my].get_ylim()[0], str(xtick), rotation=270, fontdict={&quot;horizontalalignment&quot;:&quot;center&quot;}) # 7.3. labels font_label = {&quot;color&quot;: &quot;gray&quot;, &quot;fontsize&quot;:&quot;large&quot;} labelpad = 12 for i, x in zip(axes_j, xlabels): axs[i].set_xlabel(x, fontdict=font_label, labelpad=labelpad) if i == ncols: axs[i].set_ylabel(ylabel, fontdict=font_label, labelpad=labelpad) axs[0].set_ylabel(&quot;Density&quot;, fontdict=font_label, labelpad=labelpad) axs[2*ncols-1].set_xlabel(&quot;Density&quot;, fontdict=font_label, labelpad=labelpad) fig.align_ylabels([axs[0], axs[ncols]]) fig.align_xlabels([axs[x] for x in range(ncols, 2*ncols)]) plt.tight_layout() return fig, axs X인자의 수가 바뀌어도 jointplot이 안정적으로 그려집니다. 1차원 분포도 표현 방식을 바꾸어 전보다 깔끔해졌습니다. 123jointplots([&quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;, &quot;flipper_length_mm&quot;], &quot;body_mass_g&quot;, penguins, hue=&quot;species&quot;, height=8, ratio=5, space=0.03, xlabels=[&quot;Bill Length (mm)&quot;, &quot;Bill Depth (mm)&quot;, &quot;Flipper Length (mm)&quot;], ylabel=&quot;Body Mass (g)&quot;) 2.4. 결론 seaborn의 jointplot을 가져다 쓰는 데 그치지 않았습니다. matplotlib의 객체지향 방식을 이용해 seaborn의 한계를 벗어날 수 있었습니다. 본 예제에서는 scatterplot과 2차원 kdeplot만 결합했습니다. 그러나 이 외에도 seaborn과 matplotlib이 제공하는 거의 모든 기능을 결합할 수 있습니다. 매뉴얼의 한계에 얽매이지 말고 상상력을 동원해 보시면 어떨까요. 출저: https://jehyunlee.github.io/2020/10/03/Python-DS-35-seaborn_matplotlib2/","link":"/2020/11/06/Seaborn_with_Matplotlib_2/"}],"tags":[],"categories":[]}