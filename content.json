{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Starthihih Create a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/10/29/hello-world/"},{"title":"titanic","text":"Kaggle API 설치 Google Colab에서 Kaggle API를 불러오려면 다음 소스코드를 실행한다. 1!pip install kaggle Requirement already satisfied: kaggle in /usr/local/lib/python3.6/dist-packages (1.5.9) Requirement already satisfied: six&gt;=1.10 in /usr/local/lib/python3.6/dist-packages (from kaggle) (1.15.0) Requirement already satisfied: urllib3 in /usr/local/lib/python3.6/dist-packages (from kaggle) (1.24.3) Requirement already satisfied: slugify in /usr/local/lib/python3.6/dist-packages (from kaggle) (0.0.1) Requirement already satisfied: python-dateutil in /usr/local/lib/python3.6/dist-packages (from kaggle) (2.8.1) Requirement already satisfied: tqdm in /usr/local/lib/python3.6/dist-packages (from kaggle) (4.41.1) Requirement already satisfied: python-slugify in /usr/local/lib/python3.6/dist-packages (from kaggle) (4.0.1) Requirement already satisfied: requests in /usr/local/lib/python3.6/dist-packages (from kaggle) (2.23.0) Requirement already satisfied: certifi in /usr/local/lib/python3.6/dist-packages (from kaggle) (2020.6.20) Requirement already satisfied: text-unidecode&gt;=1.3 in /usr/local/lib/python3.6/dist-packages (from python-slugify-&gt;kaggle) (1.3) Requirement already satisfied: chardet&lt;4,&gt;=3.0.2 in /usr/local/lib/python3.6/dist-packages (from requests-&gt;kaggle) (3.0.4) Requirement already satisfied: idna&lt;3,&gt;=2.5 in /usr/local/lib/python3.6/dist-packages (from requests-&gt;kaggle) (2.10) 1. Kaggle Token 다운로드 Kaggle에서 API Token을 다운로드 받는다. [Kaggle]-[My Account]-[API]-[Create New API Token]을 누르면 kaggle.json 파일이 다운로드 된다. 이 파일을 바탕화면에 옮긴 뒤, 아래 코드(토큰을 실행시키는 코드)를 실행 시킨다. 12345678from google.colab import filesuploaded = files.upload()for fn in uploaded.keys(): print('uploaded file &quot;{name}&quot; with length {length} bytes'.format( name=fn, length=len(uploaded[fn]))) # kaggle.json을 아래 폴더로 옮긴 뒤, file을 사용할 수 있도록 권한을 부여한다. !mkdir -p ~/.kaggle/ &amp;&amp; mv kaggle.json ~/.kaggle/ &amp;&amp; chmod 600 ~/.kaggle/kaggle.json Upload widget is only available when the cell has been executed in the current browser session. Please rerun this cell to enable. Saving kaggle.json to kaggle.json uploaded file &quot;kaggle.json&quot; with length 66 bytes 아래 코드는 실행됬는지 확인하는 코드 1ls -1ha ~/.kaggle/kaggle.json /root/.kaggle/kaggle.json 1 2. Kaggle 데이터 불러오기 먼저 kaggle competition list를 불러온다. 1!kaggle competitions list Warning: Looks like you're using an outdated API Version, please consider updating (server 1.5.9 / client 1.5.4) ref deadline category reward teamCount userHasEntered --------------------------------------------- ------------------- --------------- --------- --------- -------------- contradictory-my-dear-watson 2030-07-01 23:59:00 Getting Started Prizes 134 False gan-getting-started 2030-07-01 23:59:00 Getting Started Prizes 185 False tpu-getting-started 2030-06-03 23:59:00 Getting Started Knowledge 315 False digit-recognizer 2030-01-01 00:00:00 Getting Started Knowledge 2356 False titanic 2030-01-01 00:00:00 Getting Started Knowledge 18058 True house-prices-advanced-regression-techniques 2030-01-01 00:00:00 Getting Started Knowledge 4536 True connectx 2030-01-01 00:00:00 Getting Started Knowledge 390 False nlp-getting-started 2030-01-01 00:00:00 Getting Started Knowledge 1184 False rock-paper-scissors 2021-02-01 23:59:00 Playground Prizes 152 False riiid-test-answer-prediction 2021-01-07 23:59:00 Featured $100,000 1466 False nfl-big-data-bowl-2021 2021-01-05 23:59:00 Analytics $100,000 0 False competitive-data-science-predict-future-sales 2020-12-31 23:59:00 Playground Kudos 9343 False halite-iv-playground-edition 2020-12-31 23:59:00 Playground Knowledge 43 False predict-volcanic-eruptions-ingv-oe 2020-12-28 23:59:00 Playground Swag 193 False hashcode-drone-delivery 2020-12-14 23:59:00 Playground Knowledge 79 False cdp-unlocking-climate-solutions 2020-12-02 23:59:00 Analytics $91,000 0 False lish-moa 2020-11-30 23:59:00 Research $30,000 3395 False google-football 2020-11-30 23:59:00 Featured $6,000 916 False conways-reverse-game-of-life-2020 2020-11-30 23:59:00 Playground Swag 131 False lyft-motion-prediction-autonomous-vehicles 2020-11-25 23:59:00 Featured $30,000 778 False 1!kaggle competitions download -c titanic Warning: Looks like you're using an outdated API Version, please consider updating (server 1.5.9 / client 1.5.4) Downloading gender_submission.csv to /content 0% 0.00/3.18k [00:00&lt;?, ?B/s] 100% 3.18k/3.18k [00:00&lt;00:00, 6.86MB/s] Downloading test.csv to /content 0% 0.00/28.0k [00:00&lt;?, ?B/s] 100% 28.0k/28.0k [00:00&lt;00:00, 23.4MB/s] Downloading train.csv to /content 0% 0.00/59.8k [00:00&lt;?, ?B/s] 100% 59.8k/59.8k [00:00&lt;00:00, 52.2MB/s] ls는 디렉터리(파일,경로) 내의 데이터 파일을 보여주는 명령어 1!ls gender_submission.csv sample_data test.csv train.csv 현재 총 4개의 데이터를 다운로드 받았다. gender_submission.csv sample_data test.csv train.csv 3. 캐글 데이터 수집 및 EDA 우선 데이터를 수집하기에 앞서서 EDA에 관한 필수 패키지를 설치하자. 1234567891011import pandas as pd # 데이터 가공 변환(deploy)import pandas_profiling # 보고서 기능 import numpy as np # 수치연산 &amp; 배열 import matplotlib as mplimport matplotlib.pyplot as pltimport seaborn as snsplt.style.use('fivethirtyeight')import warningswarnings.filterwarnings('ignore')%matplotlib inlinefrom IPython.core.display import display, HTML (1) 데이터 불러오기 지난 시간에 받은 데이터가 총 4개임을 확인했다. gender_submission.csv sample_data test.csv train.csv 여기에서는 우선 test.csv &amp; train.csv 파일을 받도록 한다. 123train = pd.read_csv('train.csv')test = pd.read_csv('test.csv')print(&quot;data import is done&quot;) data import is done (2) 데이터 확인 Kaggle 데이터를 불러오면 우선 확인해야 하는 것은 데이터셋의 크기다. 변수의 갯수 Numeric 변수 &amp; Categorical 변수의 개수 등을 파악해야 한다. Point 1 - train데이터에서 굳이 훈련데이터와 테스트 데이터를 구분할 필요는 없다. 보통 Kaggle에서는 테스트 데이터를 주기적으로 업데이트 해준다. Point 2 - 보통 test 데이터의 변수의 개수가 하나 더 작다. 1train.shape, test.shape ((891, 12), (418, 11)) 그 후 train데이터의 상위 5개의 데이터만 확인한다. 1display(train.head()) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } PassengerId Survived Pclass Name Sex Age SibSp Parch Ticket Fare Cabin Embarked 0 1 0 3 Braund, Mr. Owen Harris male 22.0 1 0 A/5 21171 7.2500 NaN S 1 2 1 1 Cumings, Mrs. John Bradley (Florence Briggs Th... female 38.0 1 0 PC 17599 71.2833 C85 C 2 3 1 3 Heikkinen, Miss. Laina female 26.0 0 0 STON/O2. 3101282 7.9250 NaN S 3 4 1 1 Futrelle, Mrs. Jacques Heath (Lily May Peel) female 35.0 1 0 113803 53.1000 C123 S 4 5 0 3 Allen, Mr. William Henry male 35.0 0 0 373450 8.0500 NaN S 아래 코드는 train.csv을 data로 변환 한다. 1data=pd.read_csv('train.csv') 1data.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } PassengerId Survived Pclass Name Sex Age SibSp Parch Ticket Fare Cabin Embarked 0 1 0 3 Braund, Mr. Owen Harris male 22.0 1 0 A/5 21171 7.2500 NaN S 1 2 1 1 Cumings, Mrs. John Bradley (Florence Briggs Th... female 38.0 1 0 PC 17599 71.2833 C85 C 2 3 1 3 Heikkinen, Miss. Laina female 26.0 0 0 STON/O2. 3101282 7.9250 NaN S 3 4 1 1 Futrelle, Mrs. Jacques Heath (Lily May Peel) female 35.0 1 0 113803 53.1000 C123 S 4 5 0 3 Allen, Mr. William Henry male 35.0 0 0 373450 8.0500 NaN S 1data.isnull().sum() PassengerId 0 Survived 0 Pclass 0 Name 0 Sex 0 Age 177 SibSp 0 Parch 0 Ticket 0 Fare 0 Cabin 687 Embarked 2 dtype: int64 The Age, Cabin and Embarked 에 대한 결측값을 구한다. 얼마나 살아남았나?1234567f,ax=plt.subplots(1,2,figsize=(18,8))data['Survived'].value_counts().plot.pie(explode=[0,0.1],autopct='%1.1f%%',ax=ax[0],shadow=True)ax[0].set_title('Survived')ax[0].set_ylabel('')sns.countplot('Survived',data=data,ax=ax[1])ax[1].set_title('Survived')plt.show() 그 사고에서 살아남은 승객이 많지 않다는 것은 명백하다. 훈련장 891명 중 350명 정도만 살아남았다. 즉, 전체 훈련장 중 38.4%만이 추락사고에서 살아남았다. 우리는 데이터로부터 더 나은 통찰력을 얻고 어떤 범주의 승객들이 살아남았는지 그리고 누가 살아남지 않았는지 보기 위해 더 많은 정보를 캐내야 한다. 우리는 데이터 세트의 다른 특징들을 사용하여 생존율을 확인하도록 노력할 것이다. Sex, Port Of Embarcation, Age 등이 특징이다. 먼저 다양한 유형의 특징을 이해하십시오. 피쳐 유형 범주형 피쳐:범주형 변수는 두 개 이상의 범주를 가진 변수 중 하나이며, 해당 형상의 각 값은 범주별로 분류할 수 있다.예를 들어, 성별은 두 개의 범주(남성과 여성)를 갖는 범주형 변수다. 이제 우리는 그러한 변수들에 대해 어떠한 순서도 정렬할 수 없다. 이 변수들은 공칭 변수라고도 한다. 데이터 집합의 범주형 특징: 성별, 도착. 순서형 피쳐:순서형 변수는 범주형 값과 비슷하지만, 그 값들 사이의 차이는 우리가 상대적인 순서나 값들 사이의 정렬을 가질 수 있다는 것이다. 예를 들어: 높이에 높은 값, 중간 값, 짧은 값과 같은 특징이 있다면 높이는 서수 변수다. 여기서 우리는 변수에서 상대적인 분류법을 가질 수 있다. 데이터 집합의 순서형 기능: PClass 연속 기능:형상은 형상 열의 두 점 또는 최소값 또는 최대값 사이에 값을 취할 수 있는 경우 지속된다고 한다. 데이터 집합의 지속적인 기능: 나이 특성 분석성–&gt; 범주형 특징 1data.groupby(['Sex','Survived'])['Survived'].count() Sex Survived female 0 81 1 233 male 0 468 1 109 Name: Survived, dtype: int64 123456f,ax=plt.subplots(1,2,figsize=(18,8))data[['Sex','Survived']].groupby(['Sex']).mean().plot.bar(ax=ax[0])ax[0].set_title('Survived vs Sex')sns.countplot('Sex',hue='Survived',data=data,ax=ax[1])ax[1].set_title('Sex:Survived vs Dead')plt.show() 배에 타고 있는 남자들의 수가 여자들의 수보다 훨씬 많다. 그러나 여전히 구조된 여성의 수는 구조된 남성의 수보다 거의 두 배나 많다. 배에 타고 있는 여성의 생존율은 약 75%인 반면 남성은 약 18-19%이다. 이것은 모델링을 위해 매우 중요한 특징으로 보인다. 하지만 그게 최고일까? 다른 기능을 확인해 봅시다. Pclass –&gt; 순서형 피쳐1pd.crosstab(data.Pclass,data.Survived,margins=True).style.background_gradient(cmap='summer_r') #T_ceb04e82_1e4a_11eb_b25f_0242ac1c0002row0_col0,#T_ceb04e82_1e4a_11eb_b25f_0242ac1c0002row1_col1,#T_ceb04e82_1e4a_11eb_b25f_0242ac1c0002row1_col2{ background-color: #ffff66; color: #000000; }#T_ceb04e82_1e4a_11eb_b25f_0242ac1c0002row0_col1{ background-color: #cee666; color: #000000; }#T_ceb04e82_1e4a_11eb_b25f_0242ac1c0002row0_col2{ background-color: #f4fa66; color: #000000; }#T_ceb04e82_1e4a_11eb_b25f_0242ac1c0002row1_col0{ background-color: #f6fa66; color: #000000; }#T_ceb04e82_1e4a_11eb_b25f_0242ac1c0002row2_col0{ background-color: #60b066; color: #000000; }#T_ceb04e82_1e4a_11eb_b25f_0242ac1c0002row2_col1{ background-color: #dfef66; color: #000000; }#T_ceb04e82_1e4a_11eb_b25f_0242ac1c0002row2_col2{ background-color: #90c866; color: #000000; }#T_ceb04e82_1e4a_11eb_b25f_0242ac1c0002row3_col0,#T_ceb04e82_1e4a_11eb_b25f_0242ac1c0002row3_col1,#T_ceb04e82_1e4a_11eb_b25f_0242ac1c0002row3_col2{ background-color: #008066; color: #f1f1f1; } Survived 0 1 All Pclass 1 80 136 216 2 97 87 184 3 372 119 491 All 549 342 891 1234567f,ax=plt.subplots(1,2,figsize=(18,8))data['Pclass'].value_counts().plot.bar(color=['#CD7F32','#FFDF00','#D3D3D3'],ax=ax[0])ax[0].set_title('Number Of Passengers By Pclass')ax[0].set_ylabel('Count')sns.countplot('Pclass',hue='Survived',data=data,ax=ax[1])ax[1].set_title('Pclass:Survived vs Dead')plt.show() P클래스사람은 돈이 모든 것을 살 수 없다고 말한다. 그러나 우리는 구조하는 동안 P클래스 1의 승객이 매우 높은 우선순위를 부여받았다는 것을 분명히 알 수 있다. P클래스 3의 탑승객 수가 훨씬 더 많았지만, 여전히 탑승객들로부터 생존하는 사람들의 수는 약 25%로 매우 낮다. P클래스의 경우 1% 생존율이 약 63%인 반면 P클래스2의 경우 약 48%이다. 그래서 돈과 지위가 중요하다. 그런 물질적인 세계. 좀 더 자세히 살펴보고 다른 흥미로운 관찰을 확인해 봅시다. 성과 P클래스 통해 생존율을 확인해보자. 1pd.crosstab([data.Sex,data.Survived],data.Pclass,margins=True).style.background_gradient(cmap='summer_r') #T_2327443c_1e4d_11eb_b25f_0242ac1c0002row0_col0,#T_2327443c_1e4d_11eb_b25f_0242ac1c0002row0_col1,#T_2327443c_1e4d_11eb_b25f_0242ac1c0002row0_col3,#T_2327443c_1e4d_11eb_b25f_0242ac1c0002row3_col2{ background-color: #ffff66; color: #000000; }#T_2327443c_1e4d_11eb_b25f_0242ac1c0002row0_col2,#T_2327443c_1e4d_11eb_b25f_0242ac1c0002row1_col2{ background-color: #f1f866; color: #000000; }#T_2327443c_1e4d_11eb_b25f_0242ac1c0002row1_col0{ background-color: #96cb66; color: #000000; }#T_2327443c_1e4d_11eb_b25f_0242ac1c0002row1_col1{ background-color: #a3d166; color: #000000; }#T_2327443c_1e4d_11eb_b25f_0242ac1c0002row1_col3{ background-color: #cfe766; color: #000000; }#T_2327443c_1e4d_11eb_b25f_0242ac1c0002row2_col0{ background-color: #a7d366; color: #000000; }#T_2327443c_1e4d_11eb_b25f_0242ac1c0002row2_col1,#T_2327443c_1e4d_11eb_b25f_0242ac1c0002row2_col3{ background-color: #85c266; color: #000000; }#T_2327443c_1e4d_11eb_b25f_0242ac1c0002row2_col2{ background-color: #6eb666; color: #000000; }#T_2327443c_1e4d_11eb_b25f_0242ac1c0002row3_col0{ background-color: #cde666; color: #000000; }#T_2327443c_1e4d_11eb_b25f_0242ac1c0002row3_col1{ background-color: #f0f866; color: #000000; }#T_2327443c_1e4d_11eb_b25f_0242ac1c0002row3_col3{ background-color: #f7fb66; color: #000000; }#T_2327443c_1e4d_11eb_b25f_0242ac1c0002row4_col0,#T_2327443c_1e4d_11eb_b25f_0242ac1c0002row4_col1,#T_2327443c_1e4d_11eb_b25f_0242ac1c0002row4_col2,#T_2327443c_1e4d_11eb_b25f_0242ac1c0002row4_col3{ background-color: #008066; color: #f1f1f1; } Pclass 1 2 3 All Sex Survived female 0 3 6 72 81 1 91 70 72 233 male 0 77 91 300 468 1 45 17 47 109 All 216 184 491 891 12sns.factorplot('Pclass','Survived',hue='Sex',data=data) #성에 따른 Pclass 생존율plt.show() 이 경우 요인 그림은 범주형 값의 분리가 쉽기 때문에 요인 그림을 사용한다. 크로스탭과 인자 플롯을 보면 Pclass1 여성 94명 중 3명만이 사망했기 때문에 Pclass1 여성 생존율이 약 95~96%라고 쉽게 유추할 수 있다. Pclass와 관계 없이 구조하는 동안 여성에게 우선권이 주어졌다는 것은 명백하다. 심지어 Pclass1 출신의 남성들도 생존율이 매우 낮다. Pclass도 중요한 특징인 것 같다. 다른 특징을 분석해보자. 나이 –&gt; 지속적 특징123print('Oldest Passenger was of:',data['Age'].max(),'Years') #최대 나이 승객print('Youngest Passenger was of:',data['Age'].min(),'Years') #최소 나이 승객 print('Average Age on the ship:',data['Age'].mean(),'Years') #평균 나이 승객 Oldest Passenger was of: 80.0 Years Youngest Passenger was of: 0.42 Years Average Age on the ship: 29.69911764705882 Years 12345678f,ax=plt.subplots(1,2,figsize=(18,8))sns.violinplot(&quot;Pclass&quot;,&quot;Age&quot;, hue=&quot;Survived&quot;, data=data,split=True,ax=ax[0])ax[0].set_title('Pclass and Age vs Survived') #제목ax[0].set_yticks(range(0,110,10)) sns.violinplot(&quot;Sex&quot;,&quot;Age&quot;, hue=&quot;Survived&quot;, data=data,split=True,ax=ax[1])ax[1].set_title('Sex and Age vs Survived') #제목ax[1].set_yticks(range(0,110,10))plt.show() 관측치:1)P클래스에 따라 자녀 수가 증가하고 10세 미만(즉, 자녀)의 패시네거 생존율은 P클래스에 관계없이 양호한 것으로 보인다. 2)Pclass1에서 20-50세의 승객의 생존 가능성은 높고 여성에게는 더욱 좋다. 3)남성의 경우 나이가 들수록 생존 가능성이 줄어든다. 앞에서 보았듯이 에이지 기능은 177개의 null 값을 가지고 있다. 이러한 NaN 값을 대체하기 위해 데이터 집합의 평균 연령을 할당할 수 있다. 그런데 문제는 나이 차이가 많은 사람들이 많았다는 겁니다. 우리는 단지 평균 나이 29세인 4살 아이를 배정할 수 없다. 승객이 어떤 연령대인지 알 수 있는 방법은 없을까? 이름 기능을 확인할 수 있어. 그 특징을 살펴보면, 우리는 그 이름들이 Mr. 또는 Mrs.와 같은 경례를 가지고 있다는 것을 알 수 있다. 따라서 우리는 Mr. Mrs와 Mrs의 평균값을 각 그룹에 할당할 수 있다. ‘’이름에 무엇이 있는가?”—&gt; 특징 :p123data['Initial']=0for i in data: data['Initial']=data.Name.str.extract('([A-Za-z]+)\\.') #인사말을 꺼내자. 자, 이제 Regex를 사용합시다. [A-Za-z]+).. 즉, A-Z 또는 a-z 사이에 있는 문자열을 찾고, 그 뒤에 .(점)이 있는 문자열을 찾는 겁니다. 그래서 우리는 이름에서 이니셜을 성공적으로 추출했다. 1pd.crosstab(data.Initial,data.Sex).T.style.background_gradient(cmap='summer_r') #성으로 이니셜 확인 #T_392ab74e_1e4f_11eb_b25f_0242ac1c0002row0_col0,#T_392ab74e_1e4f_11eb_b25f_0242ac1c0002row0_col1,#T_392ab74e_1e4f_11eb_b25f_0242ac1c0002row0_col3,#T_392ab74e_1e4f_11eb_b25f_0242ac1c0002row0_col4,#T_392ab74e_1e4f_11eb_b25f_0242ac1c0002row0_col5,#T_392ab74e_1e4f_11eb_b25f_0242ac1c0002row0_col7,#T_392ab74e_1e4f_11eb_b25f_0242ac1c0002row0_col8,#T_392ab74e_1e4f_11eb_b25f_0242ac1c0002row0_col12,#T_392ab74e_1e4f_11eb_b25f_0242ac1c0002row0_col15,#T_392ab74e_1e4f_11eb_b25f_0242ac1c0002row0_col16,#T_392ab74e_1e4f_11eb_b25f_0242ac1c0002row1_col2,#T_392ab74e_1e4f_11eb_b25f_0242ac1c0002row1_col6,#T_392ab74e_1e4f_11eb_b25f_0242ac1c0002row1_col9,#T_392ab74e_1e4f_11eb_b25f_0242ac1c0002row1_col10,#T_392ab74e_1e4f_11eb_b25f_0242ac1c0002row1_col11,#T_392ab74e_1e4f_11eb_b25f_0242ac1c0002row1_col13,#T_392ab74e_1e4f_11eb_b25f_0242ac1c0002row1_col14{ background-color: #ffff66; color: #000000; }#T_392ab74e_1e4f_11eb_b25f_0242ac1c0002row0_col2,#T_392ab74e_1e4f_11eb_b25f_0242ac1c0002row0_col6,#T_392ab74e_1e4f_11eb_b25f_0242ac1c0002row0_col9,#T_392ab74e_1e4f_11eb_b25f_0242ac1c0002row0_col10,#T_392ab74e_1e4f_11eb_b25f_0242ac1c0002row0_col11,#T_392ab74e_1e4f_11eb_b25f_0242ac1c0002row0_col13,#T_392ab74e_1e4f_11eb_b25f_0242ac1c0002row0_col14,#T_392ab74e_1e4f_11eb_b25f_0242ac1c0002row1_col0,#T_392ab74e_1e4f_11eb_b25f_0242ac1c0002row1_col1,#T_392ab74e_1e4f_11eb_b25f_0242ac1c0002row1_col3,#T_392ab74e_1e4f_11eb_b25f_0242ac1c0002row1_col4,#T_392ab74e_1e4f_11eb_b25f_0242ac1c0002row1_col5,#T_392ab74e_1e4f_11eb_b25f_0242ac1c0002row1_col7,#T_392ab74e_1e4f_11eb_b25f_0242ac1c0002row1_col8,#T_392ab74e_1e4f_11eb_b25f_0242ac1c0002row1_col12,#T_392ab74e_1e4f_11eb_b25f_0242ac1c0002row1_col15,#T_392ab74e_1e4f_11eb_b25f_0242ac1c0002row1_col16{ background-color: #008066; color: #f1f1f1; } Initial Capt Col Countess Don Dr Jonkheer Lady Major Master Miss Mlle Mme Mr Mrs Ms Rev Sir Sex female 0 0 1 0 1 0 1 0 0 182 2 1 0 125 1 0 0 male 1 2 0 1 6 1 0 2 40 0 0 0 517 0 0 6 1 좋아, Mlle이나 Mme와 같은 철자가 틀린 이니셜이 있는데 Miss를 나타낸다. 나는 그것들을 미스나 다른 가치에 대해서도 같은 것으로 대체할 것이다.아래 코드 참조 1data['Initial'].replace(['Mlle','Mme','Ms','Dr','Major','Lady','Countess','Jonkheer','Col','Rev','Capt','Sir','Don'],['Miss','Miss','Miss','Mr','Mr','Mrs','Mrs','Other','Other','Other','Mr','Mr','Mr'],inplace=True) 1data.groupby('Initial')['Age'].mean() #이니셜별 평균 연령 확인 Initial Master 4.574167 Miss 21.860000 Mr 32.739609 Mrs 35.981818 Other 45.888889 Name: Age, dtype: float64 NaN 연령 채우기 123456## 평균 연령의 Ceil 값에 NaN 값 할당data.loc[(data.Age.isnull())&amp;(data.Initial=='Mr'),'Age']=33data.loc[(data.Age.isnull())&amp;(data.Initial=='Mrs'),'Age']=36data.loc[(data.Age.isnull())&amp;(data.Initial=='Master'),'Age']=5data.loc[(data.Age.isnull())&amp;(data.Initial=='Miss'),'Age']=22data.loc[(data.Age.isnull())&amp;(data.Initial=='Other'),'Age']=46 1data.Age.isnull().any() #그래서 마침내 null 값이 남지 않게 되었다. False 12345678910f,ax=plt.subplots(1,2,figsize=(20,10))data[data['Survived']==0].Age.plot.hist(ax=ax[0],bins=20,edgecolor='black',color='red')ax[0].set_title('Survived= 0')x1=list(range(0,85,5))ax[0].set_xticks(x1)data[data['Survived']==1].Age.plot.hist(ax=ax[1],color='green',bins=20,edgecolor='black')ax[1].set_title('Survived= 1')x2=list(range(0,85,5))ax[1].set_xticks(x2)plt.show() 관측치:1)아기들 (&lt;5)은 대량으로 생존되었다. 2)가장 나이가 많은 승객은 생존했다(80년). 3)최대 사망자는 30~40세였다. 12sns.factorplot('Pclass','Survived',col='Initial',data=data)plt.show() 따라서 부녀자 우선 정책은 계층에 관계없이 적용된다. 승선 –&gt; 범주형 값1pd.crosstab([data.Embarked,data.Pclass],[data.Sex,data.Survived],margins=True).style.background_gradient(cmap='summer_r') #T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row0_col0,#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row1_col2{ background-color: #fcfe66; color: #000000; }#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row0_col1{ background-color: #d2e866; color: #000000; }#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row0_col2{ background-color: #f2f866; color: #000000; }#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row0_col3{ background-color: #d8ec66; color: #000000; }#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row0_col4,#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row2_col3{ background-color: #e8f466; color: #000000; }#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row1_col0,#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row3_col0,#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row3_col1,#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row3_col2,#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row3_col3,#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row3_col4,#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row4_col0,#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row4_col2,#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row4_col3,#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row4_col4{ background-color: #ffff66; color: #000000; }#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row1_col1,#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row6_col0{ background-color: #f9fc66; color: #000000; }#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row1_col3,#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row1_col4{ background-color: #fbfd66; color: #000000; }#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row2_col0,#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row5_col1{ background-color: #e6f266; color: #000000; }#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row2_col1{ background-color: #f0f866; color: #000000; }#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row2_col2{ background-color: #eef666; color: #000000; }#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row2_col4,#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row7_col0{ background-color: #edf666; color: #000000; }#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row4_col1{ background-color: #fefe66; color: #000000; }#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row5_col0{ background-color: #e3f166; color: #000000; }#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row5_col2{ background-color: #ecf666; color: #000000; }#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row5_col3{ background-color: #f8fc66; color: #000000; }#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row5_col4{ background-color: #ebf566; color: #000000; }#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row6_col1{ background-color: #cde666; color: #000000; }#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row6_col2{ background-color: #e4f266; color: #000000; }#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row6_col3{ background-color: #bede66; color: #000000; }#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row6_col4{ background-color: #dbed66; color: #000000; }#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row7_col1{ background-color: #bdde66; color: #000000; }#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row7_col2{ background-color: #d3e966; color: #000000; }#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row7_col3,#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row8_col1{ background-color: #dcee66; color: #000000; }#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row7_col4{ background-color: #d1e866; color: #000000; }#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row8_col0{ background-color: #52a866; color: #000000; }#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row8_col2{ background-color: #81c066; color: #000000; }#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row8_col3{ background-color: #b0d866; color: #000000; }#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row8_col4{ background-color: #9acc66; color: #000000; }#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row9_col0,#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row9_col1,#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row9_col2,#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row9_col3,#T_40b4596e_1e5b_11eb_b25f_0242ac1c0002row9_col4{ background-color: #008066; color: #f1f1f1; } Sex female male All Survived 0 1 0 1 Embarked Pclass C 1 1 42 25 17 85 2 0 7 8 2 17 3 8 15 33 10 66 Q 1 0 1 1 0 2 2 0 2 1 0 3 3 9 24 36 3 72 S 1 2 46 51 28 127 2 6 61 82 15 164 3 55 33 231 34 353 All 81 231 468 109 889 항구별 생존 가능성 1234sns.factorplot('Embarked','Survived',data=data)fig=plt.gcf()fig.set_size_inches(5,3)plt.show() 포트 C의 생존 가능성은 0.55 전후로 가장 높은 반면 S의 생존 가능성은 가장 낮다. 1234567891011f,ax=plt.subplots(2,2,figsize=(20,15))sns.countplot('Embarked',data=data,ax=ax[0,0]) #sns = seabornax[0,0].set_title('No. Of Passengers Boarded')sns.countplot('Embarked',hue='Sex',data=data,ax=ax[0,1])ax[0,1].set_title('Male-Female Split for Embarked')sns.countplot('Embarked',hue='Survived',data=data,ax=ax[1,0])ax[1,0].set_title('Embarked vs Survived')sns.countplot('Embarked',hue='Pclass',data=data,ax=ax[1,1])ax[1,1].set_title('Embarked vs Pclass')plt.subplots_adjust(wspace=0.2,hspace=0.5)plt.show() 관측치:1)S에서 탑승한 최대 탑승객. 그들 대부분은 Pclass3 출신이다. 2)C에서 온 승객들은 상당부분 살아남은 것으로 보아 운이 좋은 것으로 보인다. 그 이유는 아마도 모든 Pclass1과 Pclass2 승객을 구조했을 것이다. 3)승객 S는 부자들의 대다수가 탑승한 항구를 바라본다. 여전히 생존 가능성은 낮은데, 그것은 81% 정도 되는 Pclass3의 많은 승객들이 살아남지금은 Pclass3의 많은 승객들이 살아남지 못했기 때문이다. 4)항구 Q의 탑승객은 거의 95%가 Pclass3 출신이었다. 12sns.factorplot('Pclass','Survived',hue='Sex',col='Embarked',data=data)plt.show() 관측치:1)Pclass1과 Pclass2의 여성은 Pclass와 관계없이 생존 확률은 거의 1이다. 2)남녀 모두의 생존율이 매우 낮기 때문에 Pclass3 Passenger에게는 포트S가 매우 불행해 보인다.(돈 문제) 3)포트 Q는 거의 모두가 Pclass 3에서 온 것처럼 남자에게는 가장 어울리지 않는 것 같다. 채우기 시작 NaN우리는 최대 승객들이 S항에서 탑승하는 것을 보았듯이 NaN을 S로 대체한다. 1data['Embarked'].fillna('S',inplace=True) 1data.Embarked.isnull().any()# Finally No NaN values False SibSip–&gt;구체적 특징이 특징은 사람이 혼자 있는지 가족과 함께 있는지 여부를 나타낸다. 형제 = 형제, 자매, 의붓동생, 의붓동생, 의붓동생 배우자 = 남편, 아내 1pd.crosstab([data.SibSp],data.Survived).style.background_gradient(cmap='summer_r') #T_728ddb78_1e5f_11eb_b25f_0242ac1c0002row0_col0,#T_728ddb78_1e5f_11eb_b25f_0242ac1c0002row0_col1{ background-color: #008066; color: #f1f1f1; }#T_728ddb78_1e5f_11eb_b25f_0242ac1c0002row1_col0{ background-color: #c4e266; color: #000000; }#T_728ddb78_1e5f_11eb_b25f_0242ac1c0002row1_col1{ background-color: #77bb66; color: #000000; }#T_728ddb78_1e5f_11eb_b25f_0242ac1c0002row2_col0,#T_728ddb78_1e5f_11eb_b25f_0242ac1c0002row4_col0{ background-color: #f9fc66; color: #000000; }#T_728ddb78_1e5f_11eb_b25f_0242ac1c0002row2_col1{ background-color: #f0f866; color: #000000; }#T_728ddb78_1e5f_11eb_b25f_0242ac1c0002row3_col0,#T_728ddb78_1e5f_11eb_b25f_0242ac1c0002row3_col1{ background-color: #fbfd66; color: #000000; }#T_728ddb78_1e5f_11eb_b25f_0242ac1c0002row4_col1{ background-color: #fcfe66; color: #000000; }#T_728ddb78_1e5f_11eb_b25f_0242ac1c0002row5_col0,#T_728ddb78_1e5f_11eb_b25f_0242ac1c0002row5_col1,#T_728ddb78_1e5f_11eb_b25f_0242ac1c0002row6_col1{ background-color: #ffff66; color: #000000; }#T_728ddb78_1e5f_11eb_b25f_0242ac1c0002row6_col0{ background-color: #fefe66; color: #000000; } Survived 0 1 SibSp 0 398 210 1 97 112 2 15 13 3 12 4 4 15 3 5 5 0 8 7 0 1234567f,ax=plt.subplots(1,2,figsize=(20,8))sns.barplot('SibSp','Survived',data=data,ax=ax[0])ax[0].set_title('SibSp vs Survived')sns.factorplot('SibSp','Survived',data=data,ax=ax[1])ax[1].set_title('SibSp vs Survived')plt.close(2)plt.show() 1pd.crosstab(data.SibSp,data.Pclass).style.background_gradient(cmap='summer_r') #T_83313358_1e5f_11eb_b25f_0242ac1c0002row0_col0,#T_83313358_1e5f_11eb_b25f_0242ac1c0002row0_col1,#T_83313358_1e5f_11eb_b25f_0242ac1c0002row0_col2{ background-color: #008066; color: #f1f1f1; }#T_83313358_1e5f_11eb_b25f_0242ac1c0002row1_col0{ background-color: #7bbd66; color: #000000; }#T_83313358_1e5f_11eb_b25f_0242ac1c0002row1_col1{ background-color: #8ac466; color: #000000; }#T_83313358_1e5f_11eb_b25f_0242ac1c0002row1_col2{ background-color: #c6e266; color: #000000; }#T_83313358_1e5f_11eb_b25f_0242ac1c0002row2_col0,#T_83313358_1e5f_11eb_b25f_0242ac1c0002row4_col2{ background-color: #f6fa66; color: #000000; }#T_83313358_1e5f_11eb_b25f_0242ac1c0002row2_col1{ background-color: #eef666; color: #000000; }#T_83313358_1e5f_11eb_b25f_0242ac1c0002row2_col2{ background-color: #f8fc66; color: #000000; }#T_83313358_1e5f_11eb_b25f_0242ac1c0002row3_col0,#T_83313358_1e5f_11eb_b25f_0242ac1c0002row3_col2{ background-color: #fafc66; color: #000000; }#T_83313358_1e5f_11eb_b25f_0242ac1c0002row3_col1{ background-color: #fdfe66; color: #000000; }#T_83313358_1e5f_11eb_b25f_0242ac1c0002row4_col0,#T_83313358_1e5f_11eb_b25f_0242ac1c0002row4_col1,#T_83313358_1e5f_11eb_b25f_0242ac1c0002row5_col0,#T_83313358_1e5f_11eb_b25f_0242ac1c0002row5_col1,#T_83313358_1e5f_11eb_b25f_0242ac1c0002row5_col2,#T_83313358_1e5f_11eb_b25f_0242ac1c0002row6_col0,#T_83313358_1e5f_11eb_b25f_0242ac1c0002row6_col1{ background-color: #ffff66; color: #000000; }#T_83313358_1e5f_11eb_b25f_0242ac1c0002row6_col2{ background-color: #fefe66; color: #000000; } Pclass 1 2 3 SibSp 0 137 120 351 1 71 55 83 2 5 8 15 3 3 1 12 4 0 0 18 5 0 0 5 8 0 0 7 관측치:막대 그래프와 요인 그림은 승객이 형제 없이 혼자 탑승한 경우 생존율이 34.5%라는 것을 보여준다. 형제자매 수가 증가하면 그래프는 대략 감소한다. 이게 말이 되네. 즉, 만약 내가 승선하고 있는 가족이 있다면, 나는 먼저 나 자신을 구하지 않고 그들을 구하려고 노력할 것이다. 놀랍게도 5~8인 가족의 생존율은 0%이다. 이유는 Pclass일 수도 있다? 그 이유는 Pclass이다. 십자표는 SibSp&gt;3을 가진 사람이 모두 Pclass3에 있었다는 것을 보여준다. Pclass3(&gt;&gt;3)의 대가족이 모두 사망하는 일이 임박했다. Parch1pd.crosstab(data.Parch,data.Pclass).style.background_gradient(cmap='summer_r') #T_ccb5b4d6_1e5f_11eb_b25f_0242ac1c0002row0_col0,#T_ccb5b4d6_1e5f_11eb_b25f_0242ac1c0002row0_col1,#T_ccb5b4d6_1e5f_11eb_b25f_0242ac1c0002row0_col2{ background-color: #008066; color: #f1f1f1; }#T_ccb5b4d6_1e5f_11eb_b25f_0242ac1c0002row1_col0{ background-color: #cfe766; color: #000000; }#T_ccb5b4d6_1e5f_11eb_b25f_0242ac1c0002row1_col1{ background-color: #c2e066; color: #000000; }#T_ccb5b4d6_1e5f_11eb_b25f_0242ac1c0002row1_col2{ background-color: #dbed66; color: #000000; }#T_ccb5b4d6_1e5f_11eb_b25f_0242ac1c0002row2_col0{ background-color: #dfef66; color: #000000; }#T_ccb5b4d6_1e5f_11eb_b25f_0242ac1c0002row2_col1{ background-color: #e1f066; color: #000000; }#T_ccb5b4d6_1e5f_11eb_b25f_0242ac1c0002row2_col2{ background-color: #e3f166; color: #000000; }#T_ccb5b4d6_1e5f_11eb_b25f_0242ac1c0002row3_col0,#T_ccb5b4d6_1e5f_11eb_b25f_0242ac1c0002row4_col1,#T_ccb5b4d6_1e5f_11eb_b25f_0242ac1c0002row5_col0,#T_ccb5b4d6_1e5f_11eb_b25f_0242ac1c0002row5_col1,#T_ccb5b4d6_1e5f_11eb_b25f_0242ac1c0002row6_col0,#T_ccb5b4d6_1e5f_11eb_b25f_0242ac1c0002row6_col1,#T_ccb5b4d6_1e5f_11eb_b25f_0242ac1c0002row6_col2{ background-color: #ffff66; color: #000000; }#T_ccb5b4d6_1e5f_11eb_b25f_0242ac1c0002row3_col1{ background-color: #fcfe66; color: #000000; }#T_ccb5b4d6_1e5f_11eb_b25f_0242ac1c0002row3_col2,#T_ccb5b4d6_1e5f_11eb_b25f_0242ac1c0002row4_col0,#T_ccb5b4d6_1e5f_11eb_b25f_0242ac1c0002row4_col2{ background-color: #fefe66; color: #000000; }#T_ccb5b4d6_1e5f_11eb_b25f_0242ac1c0002row5_col2{ background-color: #fdfe66; color: #000000; } Pclass 1 2 3 Parch 0 163 134 381 1 31 32 55 2 21 16 43 3 0 2 3 4 1 0 3 5 0 0 5 6 0 0 1 크로스탭은 다시 더 큰 가족이 Pclass3에 있었다는 것을 보여준다. 1234567f,ax=plt.subplots(1,2,figsize=(20,8))sns.barplot('Parch','Survived',data=data,ax=ax[0])ax[0].set_title('Parch vs Survived')sns.factorplot('Parch','Survived',data=data,ax=ax[1])ax[1].set_title('Parch vs Survived')plt.close(2)plt.show() 관측치:여기에서도 결과는 꽤 비슷하다. 부모를 동반한 승객은 생존 가능성이 더 크다. 하지만 숫자가 늘어날수록 줄어든다. 생존 가능성은 배 안에 1-3명의 부모를 둔 사람에게 좋다. 혼자라는 것은 또한 치명적이고 누군가가 배에 4명 이상의 부모를 두고 있을 때 생존 가능성이 줄어든다는 것을 증명한다. 운임–&gt; 지속적 특징123print('Highest Fare was:',data['Fare'].max()) #최고 요금print('Lowest Fare was:',data['Fare'].min()) #최저 요금print('Average Fare was:',data['Fare'].mean()) #평균 요금 Highest Fare was: 512.3292 Lowest Fare was: 0.0 Average Fare was: 32.2042079685746 12345678f,ax=plt.subplots(1,3,figsize=(20,8))sns.distplot(data[data['Pclass']==1].Fare,ax=ax[0])ax[0].set_title('Fares in Pclass 1')sns.distplot(data[data['Pclass']==2].Fare,ax=ax[1])ax[1].set_title('Fares in Pclass 2')sns.distplot(data[data['Pclass']==3].Fare,ax=ax[2])ax[2].set_title('Fares in Pclass 3')plt.show() Pclass1의 승객 요금에는 큰 배분이 있을 것으로 보이며, 이 배분은 기준이 감소함에 따라 계속 감소하고 있다. 이것 또한 지속적이기 때문에 우리는 바이닝을 사용하여 이산값으로 변환할 수 있다. 모든 형상에 대한 간단한 관측치:성=남성에 비해 여성의 생존 가능성은 높다. Pclass:일등석 승객이 되면 생존 가능성이 더 높아진다는 눈에 띄는 추세가 있다. Pclass3의 생존율은 매우 낮다. 여성의 경우 Pclass1에서 생존할 확률은 거의 1이며 Pclass2에서 생존할 확률도 높다. 돈이 이긴다!!! 나이: 5~10세 미만의 어린이들은 생존 확률이 높다. 15세에서 35세 사이의 승객들이 많이 죽었다. 시작됨: 이것은 매우 흥미로운 특징이다. Pclass1 승객의 대다수가 S. Q. 승객들이 모두 Pclass3 출신이었음에도 불구하고 C에서 생존할 가능성은 더 좋아 보인다. Parch+SibSp: 1-2명의 형제자매가 있고, 기내에 스파우스를 두거나, 1-3명의 부모가 혼자 있거나, 대가족이 당신과 함께 여행하는 것보다 가능성이 더 높다. 특색 간의 상관 관계1234sns.heatmap(data.corr(),annot=True,cmap='RdYlGn',linewidths=0.2) #data.corr()--&gt;상관 행렬fig=plt.gcf()fig.set_size_inches(10,8)plt.show()","link":"/2020/11/04/titanic/"},{"title":"home_credit_default_risk","text":"Kaggle API 설치 Google Colab에서 Kaggle API를 불러오려면 다음 소스코드를 실행한다. 1!pip install kaggle Requirement already satisfied: kaggle in /usr/local/lib/python3.6/dist-packages (1.5.9) Requirement already satisfied: requests in /usr/local/lib/python3.6/dist-packages (from kaggle) (2.23.0) Requirement already satisfied: slugify in /usr/local/lib/python3.6/dist-packages (from kaggle) (0.0.1) Requirement already satisfied: urllib3 in /usr/local/lib/python3.6/dist-packages (from kaggle) (1.24.3) Requirement already satisfied: tqdm in /usr/local/lib/python3.6/dist-packages (from kaggle) (4.41.1) Requirement already satisfied: python-slugify in /usr/local/lib/python3.6/dist-packages (from kaggle) (4.0.1) Requirement already satisfied: six&gt;=1.10 in /usr/local/lib/python3.6/dist-packages (from kaggle) (1.15.0) Requirement already satisfied: certifi in /usr/local/lib/python3.6/dist-packages (from kaggle) (2020.6.20) Requirement already satisfied: python-dateutil in /usr/local/lib/python3.6/dist-packages (from kaggle) (2.8.1) Requirement already satisfied: idna&lt;3,&gt;=2.5 in /usr/local/lib/python3.6/dist-packages (from requests-&gt;kaggle) (2.10) Requirement already satisfied: chardet&lt;4,&gt;=3.0.2 in /usr/local/lib/python3.6/dist-packages (from requests-&gt;kaggle) (3.0.4) Requirement already satisfied: text-unidecode&gt;=1.3 in /usr/local/lib/python3.6/dist-packages (from python-slugify-&gt;kaggle) (1.3) 1. Kaggle Token 다운로드 Kaggle에서 API Token을 다운로드 받는다. [Kaggle]-[My Account]-[API]-[Create New API Token]을 누르면 kaggle.json 파일이 다운로드 된다. 이 파일을 바탕화면에 옮긴 뒤, 아래 코드(토큰을 실행시키는 코드)를 실행 시킨다. 12345678from google.colab import filesuploaded = files.upload()for fn in uploaded.keys(): print('uploaded file &quot;{name}&quot; with length {length} bytes'.format( name=fn, length=len(uploaded[fn]))) # kaggle.json을 아래 폴더로 옮긴 뒤, file을 사용할 수 있도록 권한을 부여한다. !mkdir -p ~/.kaggle/ &amp;&amp; mv kaggle.json ~/.kaggle/ &amp;&amp; chmod 600 ~/.kaggle/kaggle.json Upload widget is only available when the cell has been executed in the current browser session. Please rerun this cell to enable. Saving kaggle.json to kaggle.json uploaded file &quot;kaggle.json&quot; with length 66 bytes 아래 코드는 실행됬는지 확인하는 코드 1ls -1ha ~/.kaggle/kaggle.json /root/.kaggle/kaggle.json 2. Kaggle 데이터 불러오기 먼저 kaggle competition list를 불러온다. 1!kaggle competitions list Warning: Looks like you're using an outdated API Version, please consider updating (server 1.5.9 / client 1.5.4) ref deadline category reward teamCount userHasEntered --------------------------------------------- ------------------- --------------- --------- --------- -------------- contradictory-my-dear-watson 2030-07-01 23:59:00 Getting Started Prizes 134 False gan-getting-started 2030-07-01 23:59:00 Getting Started Prizes 161 False tpu-getting-started 2030-06-03 23:59:00 Getting Started Knowledge 292 False digit-recognizer 2030-01-01 00:00:00 Getting Started Knowledge 2248 False titanic 2030-01-01 00:00:00 Getting Started Knowledge 17260 True house-prices-advanced-regression-techniques 2030-01-01 00:00:00 Getting Started Knowledge 4325 True connectx 2030-01-01 00:00:00 Getting Started Knowledge 366 False nlp-getting-started 2030-01-01 00:00:00 Getting Started Knowledge 1130 False rock-paper-scissors 2021-02-01 23:59:00 Playground Prizes 226 False riiid-test-answer-prediction 2021-01-07 23:59:00 Featured $100,000 1491 False nfl-big-data-bowl-2021 2021-01-05 23:59:00 Analytics $100,000 0 False competitive-data-science-predict-future-sales 2020-12-31 23:59:00 Playground Kudos 9392 False halite-iv-playground-edition 2020-12-31 23:59:00 Playground Knowledge 44 False predict-volcanic-eruptions-ingv-oe 2020-12-28 23:59:00 Playground Swag 198 False hashcode-drone-delivery 2020-12-14 23:59:00 Playground Knowledge 80 False cdp-unlocking-climate-solutions 2020-12-02 23:59:00 Analytics $91,000 0 False lish-moa 2020-11-30 23:59:00 Research $30,000 3454 False google-football 2020-11-30 23:59:00 Featured $6,000 925 False conways-reverse-game-of-life-2020 2020-11-30 23:59:00 Playground Swag 132 False lyft-motion-prediction-autonomous-vehicles 2020-11-25 23:59:00 Featured $30,000 788 False 1!kaggle competitions download -c home-credit-default-risk Warning: Looks like you're using an outdated API Version, please consider updating (server 1.5.9 / client 1.5.4) installments_payments.csv.zip: Skipping, found more recently modified local copy (use --force to force download) previous_application.csv.zip: Skipping, found more recently modified local copy (use --force to force download) application_test.csv.zip: Skipping, found more recently modified local copy (use --force to force download) bureau.csv.zip: Skipping, found more recently modified local copy (use --force to force download) sample_submission.csv: Skipping, found more recently modified local copy (use --force to force download) POS_CASH_balance.csv.zip: Skipping, found more recently modified local copy (use --force to force download) credit_card_balance.csv.zip: Skipping, found more recently modified local copy (use --force to force download) HomeCredit_columns_description.csv: Skipping, found more recently modified local copy (use --force to force download) application_train.csv.zip: Skipping, found more recently modified local copy (use --force to force download) bureau_balance.csv.zip: Skipping, found more recently modified local copy (use --force to force download) ls는 디렉터리(파일,경로) 내의 데이터 파일을 보여주는 명령어 1!ls application_test.csv.zip installments_payments.csv.zip application_train.csv.zip POS_CASH_balance.csv.zip bureau_balance.csv.zip previous_application.csv.zip bureau.csv.zip sample_data credit_card_balance.csv.zip sample_submission.csv gender_submission.csv test.csv HomeCredit_columns_description.csv train.csv 12345678! unzip application_test.csv.zip ! unzipinstallments_payments.csv.zip! unzip application_train.csv.zip ! unzip POS_CASH_balance.csv.zip! unzip bureau_balance.csv.zip ! unzip previous_application.csv.zip! unzip bureau.csv.zip ! unzip credit_card_balance.csv.zip Archive: application_test.csv.zip inflating: application_test.csv /bin/bash: unzipinstallments_payments.csv.zip: command not found Archive: application_train.csv.zip replace application_train.csv? [y]es, [n]o, [A]ll, [N]one, [r]ename: y inflating: application_train.csv Archive: POS_CASH_balance.csv.zip replace POS_CASH_balance.csv? [y]es, [n]o, [A]ll, [N]one, [r]ename: y inflating: POS_CASH_balance.csv Archive: bureau_balance.csv.zip replace bureau_balance.csv? [y]es, [n]o, [A]ll, [N]one, [r]ename: y inflating: bureau_balance.csv Archive: previous_application.csv.zip replace previous_application.csv? [y]es, [n]o, [A]ll, [N]one, [r]ename: y inflating: previous_application.csv Archive: bureau.csv.zip replace bureau.csv? [y]es, [n]o, [A]ll, [N]one, [r]ename: y inflating: bureau.csv Archive: credit_card_balance.csv.zip replace credit_card_balance.csv? [y]es, [n]o, [A]ll, [N]one, [r]ename: y inflating: credit_card_balance.csv 현재 총 14개의 데이터를 다운로드 받았다. application_test.csv.zip installments_payments.csv.zip application_train.csv.zip POS_CASH_balance.csv.zip bureau_balance.csv.zip previous_application.csv.zip bureau.csv.zip sample_data credit_card_balance.csv.zip sample_submission.csv gender_submission.csv test.csv HomeCredit_columns_description.csv train.csv 3. 캐글 데이터 수집 및 EDA 우선 데이터를 수집하기에 앞서서 EDA에 관한 필수 패키지를 설치하자. 12345678910111213# 데이터 조작을 위한 numpy와 팬더import numpy as npimport pandas as pd # 범주형 변수를 처리하기 위한 사전 처리 학습from sklearn.preprocessing import LabelEncoder# 파일 시스템 매니지먼트import os# 경고 억제import warningswarnings.filterwarnings('ignore')# 플롯을 위한 matplotlib 및 seaornimport matplotlib.pyplot as pltimport seaborn as sns 분류 감독됨: 라벨은 교육 데이터에 포함되며, 목적은 형상으로부터 라벨을 예측하는 방법을 학습하는 모델을 훈련시키는 것이다. 분류: 라벨은 0(대출금을 제때 상환할 수 있음), 1(대출금 상환에 어려움이 있음)의 이진 변수다. 데이터 : 은행을 이용하지 않은 사람들에게 신용대출(대출)을 제공하는 서비스인 홈 크레딧에 의해 제공된다 12# 사용 가능한 파일 나열print(os.listdir()) ['.config', 'previous_application.csv', 'application_train.csv', 'bureau_balance.csv', 'application_test.csv.zip', 'bureau.csv', 'POS_CASH_balance.csv', 'previous_application.csv.zip', 'bureau_balance.csv.zip', 'POS_CASH_balance.csv.zip', 'HomeCredit_columns_description.csv', 'bureau.csv.zip', 'installments_payments.csv.zip', 'test.csv', 'sample_submission.csv', 'application_train.csv.zip', 'gender_submission.csv', 'credit_card_balance.csv', 'credit_card_balance.csv.zip', 'train.csv', 'sample_data'] 1234# 교육자료app_train = pd.read_csv('application_train.csv')print('Training data shape: ', app_train.shape)app_train.head() Training data shape: (307511, 122) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } SK_ID_CURR TARGET NAME_CONTRACT_TYPE CODE_GENDER FLAG_OWN_CAR FLAG_OWN_REALTY CNT_CHILDREN AMT_INCOME_TOTAL AMT_CREDIT AMT_ANNUITY AMT_GOODS_PRICE NAME_TYPE_SUITE NAME_INCOME_TYPE NAME_EDUCATION_TYPE NAME_FAMILY_STATUS NAME_HOUSING_TYPE REGION_POPULATION_RELATIVE DAYS_BIRTH DAYS_EMPLOYED DAYS_REGISTRATION DAYS_ID_PUBLISH OWN_CAR_AGE FLAG_MOBIL FLAG_EMP_PHONE FLAG_WORK_PHONE FLAG_CONT_MOBILE FLAG_PHONE FLAG_EMAIL OCCUPATION_TYPE CNT_FAM_MEMBERS REGION_RATING_CLIENT REGION_RATING_CLIENT_W_CITY WEEKDAY_APPR_PROCESS_START HOUR_APPR_PROCESS_START REG_REGION_NOT_LIVE_REGION REG_REGION_NOT_WORK_REGION LIVE_REGION_NOT_WORK_REGION REG_CITY_NOT_LIVE_CITY REG_CITY_NOT_WORK_CITY LIVE_CITY_NOT_WORK_CITY ... LIVINGAPARTMENTS_MEDI LIVINGAREA_MEDI NONLIVINGAPARTMENTS_MEDI NONLIVINGAREA_MEDI FONDKAPREMONT_MODE HOUSETYPE_MODE TOTALAREA_MODE WALLSMATERIAL_MODE EMERGENCYSTATE_MODE OBS_30_CNT_SOCIAL_CIRCLE DEF_30_CNT_SOCIAL_CIRCLE OBS_60_CNT_SOCIAL_CIRCLE DEF_60_CNT_SOCIAL_CIRCLE DAYS_LAST_PHONE_CHANGE FLAG_DOCUMENT_2 FLAG_DOCUMENT_3 FLAG_DOCUMENT_4 FLAG_DOCUMENT_5 FLAG_DOCUMENT_6 FLAG_DOCUMENT_7 FLAG_DOCUMENT_8 FLAG_DOCUMENT_9 FLAG_DOCUMENT_10 FLAG_DOCUMENT_11 FLAG_DOCUMENT_12 FLAG_DOCUMENT_13 FLAG_DOCUMENT_14 FLAG_DOCUMENT_15 FLAG_DOCUMENT_16 FLAG_DOCUMENT_17 FLAG_DOCUMENT_18 FLAG_DOCUMENT_19 FLAG_DOCUMENT_20 FLAG_DOCUMENT_21 AMT_REQ_CREDIT_BUREAU_HOUR AMT_REQ_CREDIT_BUREAU_DAY AMT_REQ_CREDIT_BUREAU_WEEK AMT_REQ_CREDIT_BUREAU_MON AMT_REQ_CREDIT_BUREAU_QRT AMT_REQ_CREDIT_BUREAU_YEAR 0 100002 1 Cash loans M N Y 0 202500.0 406597.5 24700.5 351000.0 Unaccompanied Working Secondary / secondary special Single / not married House / apartment 0.018801 -9461 -637 -3648.0 -2120 NaN 1 1 0 1 1 0 Laborers 1.0 2 2 WEDNESDAY 10 0 0 0 0 0 0 ... 0.0205 0.0193 0.0000 0.00 reg oper account block of flats 0.0149 Stone, brick No 2.0 2.0 2.0 2.0 -1134.0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.0 0.0 0.0 0.0 0.0 1.0 1 100003 0 Cash loans F N N 0 270000.0 1293502.5 35698.5 1129500.0 Family State servant Higher education Married House / apartment 0.003541 -16765 -1188 -1186.0 -291 NaN 1 1 0 1 1 0 Core staff 2.0 1 1 MONDAY 11 0 0 0 0 0 0 ... 0.0787 0.0558 0.0039 0.01 reg oper account block of flats 0.0714 Block No 1.0 0.0 1.0 0.0 -828.0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.0 0.0 0.0 0.0 0.0 0.0 2 100004 0 Revolving loans M Y Y 0 67500.0 135000.0 6750.0 135000.0 Unaccompanied Working Secondary / secondary special Single / not married House / apartment 0.010032 -19046 -225 -4260.0 -2531 26.0 1 1 1 1 1 0 Laborers 1.0 2 2 MONDAY 9 0 0 0 0 0 0 ... NaN NaN NaN NaN NaN NaN NaN NaN NaN 0.0 0.0 0.0 0.0 -815.0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.0 0.0 0.0 0.0 0.0 0.0 3 100006 0 Cash loans F N Y 0 135000.0 312682.5 29686.5 297000.0 Unaccompanied Working Secondary / secondary special Civil marriage House / apartment 0.008019 -19005 -3039 -9833.0 -2437 NaN 1 1 0 1 0 0 Laborers 2.0 2 2 WEDNESDAY 17 0 0 0 0 0 0 ... NaN NaN NaN NaN NaN NaN NaN NaN NaN 2.0 0.0 2.0 0.0 -617.0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 NaN NaN NaN NaN NaN NaN 4 100007 0 Cash loans M N Y 0 121500.0 513000.0 21865.5 513000.0 Unaccompanied Working Secondary / secondary special Single / not married House / apartment 0.028663 -19932 -3038 -4311.0 -3458 NaN 1 1 0 1 0 0 Core staff 1.0 2 2 THURSDAY 11 0 0 0 0 1 1 ... NaN NaN NaN NaN NaN NaN NaN NaN NaN 0.0 0.0 0.0 0.0 -1106.0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0.0 0.0 0.0 0.0 0.0 0.0 5 rows × 122 columns 교육 데이터에는 307511개의 관측치(각각 별도 대출)와 대상(우리가 예측하고자 하는 라벨)을 포함한 122개의 특징(변수)이 있다. 1234# 데이터 기능 테스트app_test = pd.read_csv('application_test.csv')print('Testing data shape: ', app_test.shape)app_test.head() Testing data shape: (48744, 121) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } SK_ID_CURR NAME_CONTRACT_TYPE CODE_GENDER FLAG_OWN_CAR FLAG_OWN_REALTY CNT_CHILDREN AMT_INCOME_TOTAL AMT_CREDIT AMT_ANNUITY AMT_GOODS_PRICE NAME_TYPE_SUITE NAME_INCOME_TYPE NAME_EDUCATION_TYPE NAME_FAMILY_STATUS NAME_HOUSING_TYPE REGION_POPULATION_RELATIVE DAYS_BIRTH DAYS_EMPLOYED DAYS_REGISTRATION DAYS_ID_PUBLISH OWN_CAR_AGE FLAG_MOBIL FLAG_EMP_PHONE FLAG_WORK_PHONE FLAG_CONT_MOBILE FLAG_PHONE FLAG_EMAIL OCCUPATION_TYPE CNT_FAM_MEMBERS REGION_RATING_CLIENT REGION_RATING_CLIENT_W_CITY WEEKDAY_APPR_PROCESS_START HOUR_APPR_PROCESS_START REG_REGION_NOT_LIVE_REGION REG_REGION_NOT_WORK_REGION LIVE_REGION_NOT_WORK_REGION REG_CITY_NOT_LIVE_CITY REG_CITY_NOT_WORK_CITY LIVE_CITY_NOT_WORK_CITY ORGANIZATION_TYPE ... LIVINGAPARTMENTS_MEDI LIVINGAREA_MEDI NONLIVINGAPARTMENTS_MEDI NONLIVINGAREA_MEDI FONDKAPREMONT_MODE HOUSETYPE_MODE TOTALAREA_MODE WALLSMATERIAL_MODE EMERGENCYSTATE_MODE OBS_30_CNT_SOCIAL_CIRCLE DEF_30_CNT_SOCIAL_CIRCLE OBS_60_CNT_SOCIAL_CIRCLE DEF_60_CNT_SOCIAL_CIRCLE DAYS_LAST_PHONE_CHANGE FLAG_DOCUMENT_2 FLAG_DOCUMENT_3 FLAG_DOCUMENT_4 FLAG_DOCUMENT_5 FLAG_DOCUMENT_6 FLAG_DOCUMENT_7 FLAG_DOCUMENT_8 FLAG_DOCUMENT_9 FLAG_DOCUMENT_10 FLAG_DOCUMENT_11 FLAG_DOCUMENT_12 FLAG_DOCUMENT_13 FLAG_DOCUMENT_14 FLAG_DOCUMENT_15 FLAG_DOCUMENT_16 FLAG_DOCUMENT_17 FLAG_DOCUMENT_18 FLAG_DOCUMENT_19 FLAG_DOCUMENT_20 FLAG_DOCUMENT_21 AMT_REQ_CREDIT_BUREAU_HOUR AMT_REQ_CREDIT_BUREAU_DAY AMT_REQ_CREDIT_BUREAU_WEEK AMT_REQ_CREDIT_BUREAU_MON AMT_REQ_CREDIT_BUREAU_QRT AMT_REQ_CREDIT_BUREAU_YEAR 0 100001 Cash loans F N Y 0 135000.0 568800.0 20560.5 450000.0 Unaccompanied Working Higher education Married House / apartment 0.018850 -19241 -2329 -5170.0 -812 NaN 1 1 0 1 0 1 NaN 2.0 2 2 TUESDAY 18 0 0 0 0 0 0 Kindergarten ... NaN 0.0514 NaN NaN NaN block of flats 0.0392 Stone, brick No 0.0 0.0 0.0 0.0 -1740.0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.0 0.0 0.0 0.0 0.0 0.0 1 100005 Cash loans M N Y 0 99000.0 222768.0 17370.0 180000.0 Unaccompanied Working Secondary / secondary special Married House / apartment 0.035792 -18064 -4469 -9118.0 -1623 NaN 1 1 0 1 0 0 Low-skill Laborers 2.0 2 2 FRIDAY 9 0 0 0 0 0 0 Self-employed ... NaN NaN NaN NaN NaN NaN NaN NaN NaN 0.0 0.0 0.0 0.0 0.0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.0 0.0 0.0 0.0 0.0 3.0 2 100013 Cash loans M Y Y 0 202500.0 663264.0 69777.0 630000.0 NaN Working Higher education Married House / apartment 0.019101 -20038 -4458 -2175.0 -3503 5.0 1 1 0 1 0 0 Drivers 2.0 2 2 MONDAY 14 0 0 0 0 0 0 Transport: type 3 ... NaN NaN NaN NaN NaN NaN NaN NaN NaN 0.0 0.0 0.0 0.0 -856.0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0.0 0.0 0.0 0.0 1.0 4.0 3 100028 Cash loans F N Y 2 315000.0 1575000.0 49018.5 1575000.0 Unaccompanied Working Secondary / secondary special Married House / apartment 0.026392 -13976 -1866 -2000.0 -4208 NaN 1 1 0 1 1 0 Sales staff 4.0 2 2 WEDNESDAY 11 0 0 0 0 0 0 Business Entity Type 3 ... 0.2446 0.3739 0.0388 0.0817 reg oper account block of flats 0.3700 Panel No 0.0 0.0 0.0 0.0 -1805.0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.0 0.0 0.0 0.0 0.0 3.0 4 100038 Cash loans M Y N 1 180000.0 625500.0 32067.0 625500.0 Unaccompanied Working Secondary / secondary special Married House / apartment 0.010032 -13040 -2191 -4000.0 -4262 16.0 1 1 1 1 0 0 NaN 3.0 2 2 FRIDAY 5 0 0 0 0 1 1 Business Entity Type 3 ... NaN NaN NaN NaN NaN NaN NaN NaN NaN 0.0 0.0 0.0 0.0 -821.0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 NaN NaN NaN NaN NaN NaN 5 rows × 121 columns 테스트 세트가 상당히 작고 대상 컬럼이 부족하다. 탐색적 데이터 분석.탐색적 데이터 분석(EDA)은 우리가 통계를 계산하고 수치를 만들어 데이터 내의 경향, 이상 징후, 패턴 또는 관계를 찾아내는 개방형 프로세스다. EDA의 목표는 우리의 데이터가 우리에게 말해줄 수 있는 것을 배우는 것이다. 일반적으로 높은 수준의 개요에서 시작되며, 데이터에서 흥미로운 영역을 발견하면 특정 영역으로 좁혀진다. 그 결과들은 그 자체로 흥미로울 수도 있고, 어떤 기능을 사용할지 결정하는 것을 도와줌으로써 우리의 모델 선택을 알리는 데 사용될 수도 있다. 대상 열의 분포 조사대상은 대출금 0을 제때 상환했거나 고객이 상환에 어려움을 겪었음을 나타내는 1을 예측하라는 것이다. 우리는 우선 각 범주에 속하는 대출의 수를 조사할 수 있다. 1app_train['TARGET'].value_counts() 0 282686 1 24825 Name: TARGET, dtype: int64 1app_train['TARGET'].astype(int).plot.hist(); 이 정보로부터, 우리는 이것이 불균형한 계급 문제임을 알 수 있다. 제때 갚지 못한 대출보다 제때 갚은 대출이 훨씬 많다. 일단 우리가 좀 더 정교한 기계 학습 모델에 들어가면, 우리는 이러한 불균형을 반영하기 위해 데이터에서의 그들의 표현에 따라 수업에 무게를 둘 수 있다. 결측값 검사다음으로 각 열에 있는 결측값의 수와 백분율을 살펴보기로 한다. 123456789101112131415161718192021222324252627# 결측값을 열로 계산하는 함수 #Funct def missing_values_table(df): # 결측값 합계 mis_val = df.isnull().sum() # 결측값 백분율 mis_val_percent = 100 * df.isnull().sum() / len(df) # 결과로 테이블 만들기 mis_val_table = pd.concat([mis_val, mis_val_percent], axis=1) # 열 이름 바꾸기 mis_val_table_ren_columns = mis_val_table.rename( columns = {0 : 'Missing Values', 1 : '% of Total Values'}) # 누락된 내림차순 백분율을 기준으로 테이블 정렬 mis_val_table_ren_columns = mis_val_table_ren_columns[ mis_val_table_ren_columns.iloc[:,1] != 0].sort_values( '% of Total Values', ascending=False).round(1) # 일부 요약 정보 인쇄 print (&quot;Your selected dataframe has &quot; + str(df.shape[1]) + &quot; columns.\\n&quot; &quot;There are &quot; + str(mis_val_table_ren_columns.shape[0]) + &quot; columns that have missing values.&quot;) # 누락된 정보가 있는 데이터 프레임 반환 return mis_val_table_ren_columns 123# 결측값 통계량missing_values = missing_values_table(app_train)missing_values.head(20) Your selected dataframe has 122 columns. There are 67 columns that have missing values. .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Missing Values % of Total Values COMMONAREA_MEDI 214865 69.9 COMMONAREA_AVG 214865 69.9 COMMONAREA_MODE 214865 69.9 NONLIVINGAPARTMENTS_MEDI 213514 69.4 NONLIVINGAPARTMENTS_MODE 213514 69.4 NONLIVINGAPARTMENTS_AVG 213514 69.4 FONDKAPREMONT_MODE 210295 68.4 LIVINGAPARTMENTS_MODE 210199 68.4 LIVINGAPARTMENTS_MEDI 210199 68.4 LIVINGAPARTMENTS_AVG 210199 68.4 FLOORSMIN_MODE 208642 67.8 FLOORSMIN_MEDI 208642 67.8 FLOORSMIN_AVG 208642 67.8 YEARS_BUILD_MODE 204488 66.5 YEARS_BUILD_MEDI 204488 66.5 YEARS_BUILD_AVG 204488 66.5 OWN_CAR_AGE 202929 66.0 LANDAREA_AVG 182590 59.4 LANDAREA_MEDI 182590 59.4 LANDAREA_MODE 182590 59.4 열 유형각 데이터 유형의 열 수를 살펴보자. int64와 float64는 숫자 변수(이산형 또는 연속형일 수 있음)이다. 객체 열은 문자열을 포함하며 범주형 형상이다. 12# 각 열 유형별 수app_train.dtypes.value_counts() float64 65 int64 41 object 16 dtype: int64 이제 각 개체(범주형) 열에 있는 고유한 항목 수를 살펴봅시다. 12# 각 객체 열의 고유 클래스 수app_train.select_dtypes('object').apply(pd.Series.nunique, axis = 0) NAME_CONTRACT_TYPE 2 CODE_GENDER 3 FLAG_OWN_CAR 2 FLAG_OWN_REALTY 2 NAME_TYPE_SUITE 7 NAME_INCOME_TYPE 8 NAME_EDUCATION_TYPE 5 NAME_FAMILY_STATUS 6 NAME_HOUSING_TYPE 6 OCCUPATION_TYPE 18 WEEKDAY_APPR_PROCESS_START 7 ORGANIZATION_TYPE 58 FONDKAPREMONT_MODE 4 HOUSETYPE_MODE 3 WALLSMATERIAL_MODE 7 EMERGENCYSTATE_MODE 2 dtype: int64 대부분의 범주형 변수의 고유 항목 수는 상대적으로 적다. 우리는 이러한 범주형 변수에 대처할 방법을 찾아야 할 것이다! 범주형 변수를 인코딩하는 중:더 나아가기 전에 성가신 범주형 변수를 다뤄야 한다. 기계 학습 모델은 유감스럽게도 범주형 변수를 다룰 수 없다(LightGBM과 같은 일부 모델은 제외). 따라서 이 변수들을 모델로 넘기기 전에 숫자로 인코딩(표현)하는 방법을 찾아야 한다. 이 과정을 수행하는 방법에는 크게 두 가지가 있다. 라벨 인코딩: 정수를 사용하여 범주형 변수의 각 고유 범주를 할당하십시오. 새 열이 생성되지 않음 예는 아래와 같다. 단일 핫 인코딩: 범주형 변수의 각 고유 범주에 대해 새 열을 생성하십시오. 각 관측치는 해당 범주에 대해 열에 1을, 다른 모든 새 열에 0을 받는다. 라벨 인코딩의 문제는 카테고리에 임의의 순서를 부여한다는 것이다. 각 범주에 할당된 값은 랜덤이며 범주의 고유한 측면을 반영하지 않는다. 위의 예에서 프로그래머는 4를, 데이터 과학자는 1을 받지만, 만약 우리가 같은 과정을 다시 한다면, 라벨이 거꾸로 되거나 완전히 달라질 수 있다. 정수의 실제 할당은 임의적이다. 따라서 우리가 라벨 인코딩을 수행할 때 모델은 형상의 상대적 값(예: 프로그래머 = 4 및 데이터 과학자 = 1)을 사용하여 우리가 원하는 가중치를 할당할 수 있다. 범주형 변수(예: 남성/여성)에 대해 고유한 값이 두 개뿐이면 레이블 인코딩은 괜찮지만 두 개 이상의 고유한 범주에 대해서는 하나의 핫 인코딩이 안전한 옵션이다. 이러한 접근방식의 상대적 장점에 대해 일부 논쟁이 있으며, 일부 모델은 라벨로 인코딩된 범주형 변수를 문제 없이 다룰 수 있다. 여기 좋은 스택 오버플로 토론이 있다. 클래스가 많은 범주형 변수에 대해서는 (그리고 이것은 개인적인 의견일 뿐이다) 하나의 핫 인코딩이 범주에 임의의 값을 부과하지 않기 때문에 가장 안전한 접근법이라고 생각한다. 단일 핫 인코딩의 유일한 단점은 피쳐 수(데이터의 치수)가 범주가 많은 범주형 변수로 폭발할 수 있다는 점이다. 이를 처리하기 위해 PCA나 기타 차원성 감소 방법에 따라 1회 핫 인코딩을 수행하여 치수 수를 줄일 수 있다(여전히 정보 보존을 위해 노력). 이 노트북에서는 범주 2개만 있는 범주형 변수에 레이블 인코딩을 사용하고 범주 2개 이상의 범주형 변수에 대해 One-Hot 인코딩을 사용할 것이다. 이 과정은 프로젝트에 더 깊이 들어가면서 변화가 필요할 수 있지만, 현재로서는 이것이 우리에게 어떤 영향을 미치는지 알 수 있을 것이다. (우리는 또한 이 노트북에서 어떠한 차원성 감소도 사용하지 않고 향후 반복해서 검토할 것이다.) 레이블 인코딩 및 단일 핫 인코딩위에서 설명한 정책을 실행하자: 2개의 고유한 범주를 가진 범주형 변수(dtype == 객체)에 대해서는 레이블 인코딩을 사용하고, 2개 이상의 고유한 범주를 가진 범주형 변수에 대해서는 1-hot 인코딩을 사용한다. 라벨 인코딩의 경우 Scikit-Learn LabelEncoder를 사용하고, 핫 인코딩의 경우 팬더 get_dummies(df) 기능을 사용한다. 12345678910111213141516171819# 레이블 인코더 객체 생성le = LabelEncoder()le_count = 0# 열을 반복하십시오for col in app_train: if app_train[col].dtype == 'object': # 고유 범주가 2개 이하인 경우 if len(list(app_train[col].unique())) &lt;= 2: # 교육 데이터 교육 le.fit(app_train[col]) # 교육 및 테스트 데이터 모두 혁신 app_train[col] = le.transform(app_train[col]) app_test[col] = le.transform(app_test[col]) # 레이블이 인코딩된 열 수를 추적 le_count += 1 print('%d columns were label encoded.' % le_count) 0 columns were label encoded. 123456# 범주형 변수의 단일 핫 인코딩app_train = pd.get_dummies(app_train)app_test = pd.get_dummies(app_test)print('Training Features shape: ', app_train.shape)print('Testing Features shape: ', app_test.shape) Training Features shape: (307511, 243) Testing Features shape: (48744, 239) 교육 및 테스트 데이터 정렬훈련 데이터와 시험 데이터 모두에서 동일한 특징(색상)이 있어야 한다. 원핫 인코딩은 시험 데이터에 나타나지 않는 범주를 포함하는 일부 범주형 변수가 있었기 때문에 훈련 데이터에 더 많은 열을 생성했다. 테스트 데이터에 없는 교육 데이터 열을 제거하려면 데이터 프레임을 정렬해야 한다. 먼저 교육 데이터에서 대상 열을 추출한다(시험 데이터에는 없지만 이 정보를 보관해야 하기 때문이다). 정렬을 수행할 때 행이 아닌 열에 따라 데이터 프레임을 정렬하도록 축 = 1을 설정해야 함! 12345678910train_labels = app_train['TARGET']# 교육 및 테스트 데이터 정렬, 두 데이터 프레임에 열만 유지app_train, app_test = app_train.align(app_test, join = 'inner', axis = 1)# 목표값 다시 추가app_train['TARGET'] = train_labelsprint('Training Features shape: ', app_train.shape)print('Testing Features shape: ', app_test.shape) Training Features shape: (307511, 240) Testing Features shape: (48744, 239) 교육 및 테스트 데이터셋은 이제 머신러닝에 필요한 기능과 동일한 기능을 가지고 있다. 원핫 인코딩으로 피쳐 수가 크게 늘었다. 데이터셋 크기를 줄이기 위해 언젠가는 차원성 축소(관련되지 않은 기능 제거)를 시도해보려고 할 것이다. 탐색 데이터 분석으로 돌아가기이상 징후우리가 EDA를 할 때 항상 경계하고 싶은 한 가지 문제는 데이터 내의 이상 현상이다. 이는 잘못된 형식의 숫자, 측정 장비의 오류 또는 유효하지만 극단적인 측정 때문일 수 있다. 이상 징후를 정량적으로 지원하는 한 가지 방법은 설명 방법을 사용하여 열의 통계를 보는 것이다. DAYS_BOYDE 칼럼의 숫자는 현재 대출 신청과 관련하여 기록되기 때문에 음수가 된다. 이러한 통계치를 년 단위로 보려면 -1로 나누어 1년 내 일수로 나누면 된다. 1(app_train['DAYS_BIRTH'] / -365).describe() count 307511.000000 mean 43.936973 std 11.956133 min 20.517808 25% 34.008219 50% 43.150685 75% 53.923288 max 69.120548 Name: DAYS_BIRTH, dtype: float64 그 나이들은 합리적으로 보인다. 높은 쪽이든 낮은 쪽이든 나이에 대한 특이치는 없다. 1app_train['DAYS_EMPLOYED'].describe() count 307511.000000 mean 63815.045904 std 141275.766519 min -17912.000000 25% -2760.000000 50% -1213.000000 75% -289.000000 max 365243.000000 Name: DAYS_EMPLOYED, dtype: float64 그건 옳지 않아! 최대값(긍정적인 것 외에)은 약 1000년 12app_train['DAYS_EMPLOYED'].plot.hist(title = 'Days Employment Histogram');plt.xlabel('Days Employment'); 그냥 궁금해서 변칙적인 고객들을 부분집합해서 나머지 고객들보다 채무불이행 비율이 더 높은지 낮은지 살펴보자. 12345anom = app_train[app_train['DAYS_EMPLOYED'] == 365243]non_anom = app_train[app_train['DAYS_EMPLOYED'] != 365243]print('The non-anomalies default on %0.2f%% of loans' % (100 * non_anom['TARGET'].mean()))print('The anomalies default on %0.2f%% of loans' % (100 * anom['TARGET'].mean()))print('There are %d anomalous days of employment' % len(anom)) The non-anomalies default on 8.66% of loans The anomalies default on 5.40% of loans There are 55374 anomalous days of employment 이상 징후는 채무불이행 비율이 낮은 것으로 나타났다. 이상 징후를 다루는 것은 정해진 규칙 없이 정확한 상황에 따라 달라진다. 가장 안전한 방법 중 하나는 기계의 학습 전에 이상 징후를 결측값으로 설정한 다음 (귀책 사용) 입력하는 것이다. 이 경우 모든 이상 징후가 정확히 동일한 가치를 가지기 때문에 이러한 모든 대출이 공통적으로 공유될 경우에 대비하여 동일한 가치로 기입하고자 한다. 변칙적인 값들은 어느 정도 중요한 것 같아, 만약 우리가 실제로 이 값을 채웠다면 우리는 기계 학습 모델을 말해주고 싶다. 해결책으로 숫자(np.nan)가 아닌 변칙값으로 채운 다음 변칙값의 변칙 여부를 나타내는 부울란을 새로 만들겠다. 12345678# 변칙적인 플래그 열 생성app_train['DAYS_EMPLOYED_ANOM'] = app_train[&quot;DAYS_EMPLOYED&quot;] == 365243# 변칙적인 값은 nan으로 대체app_train['DAYS_EMPLOYED'].replace({365243: np.nan}, inplace = True)app_train['DAYS_EMPLOYED'].plot.hist(title = 'Days Employment Histogram');plt.xlabel('Days Employment'); 분포는 우리가 예상할 수 있는 것과 훨씬 일치하는 것으로 보이며, 우리는 또한 모형에 이 값들이 원래 변칙적이라는 것을 알리기 위해 새로운 열을 만들었다. (왜냐하면 우리는 일부 값, 아마도 열의 중간값으로 난을 채워야 할 것이기 때문이다.) 데이터 프레임에 Days가 있는 다른 열은 명백한 특이치가 없는 것으로 우리가 기대하는 것에 대한 것으로 보인다. 매우 중요한 사항으로서, 교육 데이터에 대해 수행하는 모든 작업은 테스트 데이터에도 적용되어야 한다. 반드시 새 열을 만들고 기존 열을 테스트 데이터에 np.nan으로 채우자. 1234app_test['DAYS_EMPLOYED_ANOM'] = app_test[&quot;DAYS_EMPLOYED&quot;] == 365243app_test[&quot;DAYS_EMPLOYED&quot;].replace({365243: np.nan}, inplace = True)print('There are %d anomalies in the test data out of %d entries' % (app_test[&quot;DAYS_EMPLOYED_ANOM&quot;].sum(), len(app_test))) There are 9274 anomalies in the test data out of 48744 entries 상관 관계이제 범주형 변수와 특이치를 다루었으므로 EDA를 계속 진행합시다. 데이터를 이해하고 이해하는 한 가지 방법은 피쳐와 대상 간의 상관 관계를 찾는 것이다. 우리는 .corr 데이터프레임 방법을 사용하여 모든 변수와 목표값 사이의 Pearson 상관 계수를 계산할 수 있다. 상관 계수는 형상의 “관련성”을 나타내는 가장 큰 방법은 아니지만, 데이터 내에서 가능한 관계에 대한 아이디어를 제공한다. 상관관계의 절대값에 대한 일반적인 해석은 다음과 같다. .00-19 “매우 약함” .20-.39 “weak” .40-.59 “moderate” .60-.79 “강력” .80-1.0 “매우 강함” 123456# 대상과의 상관관계를 찾아 정렬correlations = app_train.corr()['TARGET'].sort_values()# 상관관계 표시print('Most Positive Correlations:\\n', correlations.tail(15))print('\\nMost Negative Correlations:\\n', correlations.head(15)) Most Positive Correlations: OCCUPATION_TYPE_Laborers 0.043019 FLAG_DOCUMENT_3 0.044346 REG_CITY_NOT_LIVE_CITY 0.044395 FLAG_EMP_PHONE 0.045982 NAME_EDUCATION_TYPE_Secondary / secondary special 0.049824 REG_CITY_NOT_WORK_CITY 0.050994 DAYS_ID_PUBLISH 0.051457 CODE_GENDER_M 0.054713 DAYS_LAST_PHONE_CHANGE 0.055218 NAME_INCOME_TYPE_Working 0.057481 REGION_RATING_CLIENT 0.058899 REGION_RATING_CLIENT_W_CITY 0.060893 DAYS_EMPLOYED 0.074958 DAYS_BIRTH 0.078239 TARGET 1.000000 Name: TARGET, dtype: float64 Most Negative Correlations: EXT_SOURCE_3 -0.178919 EXT_SOURCE_2 -0.160472 EXT_SOURCE_1 -0.155317 NAME_EDUCATION_TYPE_Higher education -0.056593 CODE_GENDER_F -0.054704 NAME_INCOME_TYPE_Pensioner -0.046209 DAYS_EMPLOYED_ANOM -0.045987 ORGANIZATION_TYPE_XNA -0.045987 FLOORSMAX_AVG -0.044003 FLOORSMAX_MEDI -0.043768 FLOORSMAX_MODE -0.043226 EMERGENCYSTATE_MODE_No -0.042201 HOUSETYPE_MODE_block of flats -0.040594 AMT_GOODS_PRICE -0.039645 REGION_POPULATION_RELATIVE -0.037227 Name: TARGET, dtype: float64 더 중요한 상관관계 몇 가지를 살펴봅시다: DAYS_BOYT는 가장 긍정적인 상관관계 입니다. (변수와 그 자체와의 상관관계가 항상 1이기 때문에 TARGET은 제외) 문서를 보면 Days_BOYT는 마이너스일(어떠한 이유로든!) 대출 당시 고객의 일(일) 연령이다. 상관관계는 양수지만, 이 특성의 값은 실제로 음수인데, 이는 클라이언트가 나이가 들수록 대출금 채무불이행(대상 == 0) 가능성이 적다는 것을 의미한다. 그건 좀 헷갈리니까 형상의 절대값을 취해서 그 다음에 상관관계는 음수가 될 겁니다. 상환연령이 상환에 미치는 영향123# 출생 후 양일간과 대상의 상관관계 찾기app_train['DAYS_BIRTH'] = abs(app_train['DAYS_BIRTH'])app_train['DAYS_BIRTH'].corr(app_train['TARGET']) -0.07823930830982694 고객이 나이가 들수록 고객이 나이가 들수록 대출금을 제때 상환하는 경향이 있다는 목표와 부정적인 선형 관계가 형성된다. 이 변수부터 살펴보자. 첫째, 우리는 시대의 히스토그램을 만들 수 있다. 우리는 그 줄거리를 좀 더 이해할 수 있도록 몇 년 안에 x축을 넣을 것이다. 123456# 플롯 스타일 설정plt.style.use('fivethirtyeight')# 연령별 연령 분포 그림 그리기plt.hist(app_train['DAYS_BIRTH'] / 365, edgecolor = 'k', bins = 25)plt.title('Age of Client'); plt.xlabel('Age (years)'); plt.ylabel('Count'); 그 자체로 연령의 분포는 모든 연령대가 합리적이기 때문에 특이치가 없다는 것 이외에는 우리에게 별로 알려주지 않는다. 연령대가 대상에 미치는 영향을 시각화하기 위해 다음으로 대상의 값으로 색칠한 KDE(커널 밀도 추정도)를 만들겠다. 커널 밀도 추정 그림은 단일 변수의 분포를 보여주며 평활 히스토그램으로 생각할 수 있다(대개 가우스인 커널을 각 데이터 지점에서 계산한 다음 모든 개별 커널을 평균하여 단일 평활 곡선을 개발함으로써 생성된다). 우리는 이 그래프에 해저 Kdeplot을 사용할 것이다. 12345678910plt.figure(figsize = (10, 8))# 제때 상환된 대출의 KDE 플롯sns.kdeplot(app_train.loc[app_train['TARGET'] == 0, 'DAYS_BIRTH'] / 365, label = 'target == 0')# 제때 상환되지 않은 대출의 KDE 플롯sns.kdeplot(app_train.loc[app_train['TARGET'] == 1, 'DAYS_BIRTH'] / 365, label = 'target == 1')# 플롯의 라벨링plt.xlabel('Age (years)'); plt.ylabel('Density'); plt.title('Distribution of Ages'); 목표 == 1 커브가 범위의 젊은 쪽 끝을 향해 기울어진다. 이는 유의미한 상관 계수(-0.07 상관 계수)는 아니지만, 이 변수는 대상에 영향을 미치기 때문에 머신러닝 모델에서 유용할 것으로 보인다. 이 관계를 다른 방식으로 보자: 평균적으로 연령대별 대출금 상환 실패. 이 그래프를 만들기 위해 먼저 나이 범주를 각각 5년씩의 빈으로 자른다. 그런 다음 각 빈에 대해 대상의 평균가치를 산출하는데, 이는 각 연령 범주별로 상환되지 않은 대출의 비율을 알려준다.","link":"/2020/11/05/home_credit_default_risk/"}],"tags":[],"categories":[]}